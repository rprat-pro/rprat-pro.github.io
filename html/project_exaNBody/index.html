<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>1. ExaNBody: Framework for N-Body Simulations on HPC Platforms &mdash; ExaDEM &amp; ExaNBody  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="1. ExaDEM Software" href="../project_exaDEM/Introduction.html" />
    <link rel="prev" title="ExaDEM &amp; ExaNBody Documentation" href="../index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            ExaDEM & ExaNBody
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">ExaNB Framework</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">1. ExaNBody: Framework for N-Body Simulations on HPC Platforms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#exadem-variant">1.1. ExaDEM Variant</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exasph-variant">1.2. ExaSPH Variant</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exastamp-variant">1.3. ExaSTAMP Variant</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#installing-exanb">2. Installing ExaNB</a></li>
<li class="toctree-l1"><a class="reference internal" href="#n-body-background">3. N-Body Background</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#n-body-methods">3.1. N-body methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="#n-body-simulation-codes">3.2. N-body simulation codes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#software-stack-of-exanbody">4. Software stack of ExaNBody</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#software-stack-layers">4.1. Software Stack Layers:</a></li>
<li class="toctree-l2"><a class="reference internal" href="#guidelines-for-operators">4.2. Guidelines for operators:</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#performance-and-portability">5. Performance and portability</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#application-level-specialization">5.1. Application level specialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#spatial-domain-decomposition-and-inter-process-communications">5.2. Spatial domain decomposition and inter-process communications</a></li>
<li class="toctree-l2"><a class="reference internal" href="#intra-node-parallelization-api">5.3. Intra-node parallelization API</a></li>
<li class="toctree-l2"><a class="reference internal" href="#particle-data-layout-and-auxiliary-data-structures">5.4. Particle data layout and auxiliary data structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="#flexible-and-user-friendly-construction-of-n-body-simulations">5.5. Flexible and user friendly construction of N-Body simulations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#algorithm-patterns">6. Algorithm Patterns</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#block-parallel-for">6.1. Block Parallel For</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#basic-usage">6.1.1. Basic usage</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynchrone-usage">6.1.2. Asynchrone usage</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#compute-cell-particles">6.2. Compute Cell Particles</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reduce-cell-particles">6.3. Reduce Cell Particles</a></li>
<li class="toctree-l2"><a class="reference internal" href="#compute-pair-interaction">6.4. Compute Pair Interaction</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#list-of-plugins">7. List of Plugins</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#defbox">7.1. DefBox</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#operator-a">7.1.1. Operator a</a></li>
<li class="toctree-l3"><a class="reference internal" href="#operator-b">7.1.2. Operator b</a></li>
<li class="toctree-l3"><a class="reference internal" href="#operator-c">7.1.3. Operator c</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#core-features">7.2. Core features</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#domain">7.2.1. Domain</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#logic">7.3. Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="#amr">7.4. AMR</a></li>
<li class="toctree-l2"><a class="reference internal" href="#particleneighbors">7.5. ParticleNeighbors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#gridcellparticles">7.6. GridCellParticles</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cartesian-field-grid">7.6.1. Cartesian Field Grid</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#io">7.7. IO</a></li>
<li class="toctree-l2"><a class="reference internal" href="#extra-storage">7.8. Extra Storage</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#extra-data-checker">7.8.1. Extra Data Checker</a></li>
<li class="toctree-l3"><a class="reference internal" href="#migrate-cell-particles-with-extra-storage">7.8.2. Migrate Cell Particles With Extra Storage</a></li>
<li class="toctree-l3"><a class="reference internal" href="#move-particles-with-extra-storage">7.8.3. Move Particles With Extra Storage</a></li>
<li class="toctree-l3"><a class="reference internal" href="#io-writer-with-extra-data">7.8.4. IO Writer With Extra Data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#io-reader-with-extra-data">7.8.5. IO Reader With Extra Data</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#mpi">7.9. MPI</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#update-ghost-layers">7.9.1. Update Ghost Layers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mpi-barrier">7.9.2. MPI Barrier</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#exanbody-command-lines">8. ExaNBody Command Lines</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#command-line-and-input-file-interaction">8.1. Command line and input file interaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#commands-help-for-your-application">8.2. Commands ‘Help’ for your application</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#general-help-command">8.2.1. General Help Command</a></li>
<li class="toctree-l3"><a class="reference internal" href="#command-line-options-help">8.2.2. Command-Line Options Help</a></li>
<li class="toctree-l3"><a class="reference internal" href="#plugins-help">8.2.3. Plugins Help</a></li>
<li class="toctree-l3"><a class="reference internal" href="#show-plugins-help">8.2.4. Show Plugins Help</a></li>
<li class="toctree-l3"><a class="reference internal" href="#operator-specific-help">8.2.5. Operator-Specific Help</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#index-of-command-line-options-to-customize-configuration-block">8.3. Index of command line options to customize configuration block</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tune-your-run-with-openmp">8.4. Tune your run with OpenMP</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tune-gpu-execution-options">8.5. Tune GPU execution options</a></li>
<li class="toctree-l2"><a class="reference internal" href="#profiling-tools-available-in-exanbody">8.6. Profiling tools available in exaNBody</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-timers-with-mpi-and-gpu">8.7. Using Timers with MPI and GPU</a></li>
<li class="toctree-l2"><a class="reference internal" href="#debug-features-in-exanbody">8.8. Debug features in exaNBody</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#tutorials">9. Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#add-a-new-plugin">9.1. Add a new plugin</a></li>
<li class="toctree-l2"><a class="reference internal" href="#add-a-new-operator">9.2. Add a new operator</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#define-your-kernel">9.2.1. Define your kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="#define-an-operator">9.2.2. Define an operator:</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#comments">9.2.2.1. Comments:</a></li>
<li class="toctree-l4"><a class="reference internal" href="#comment">9.2.2.2. Comment:</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#exanbody-publications">10. ExaNBody Publications:</a></li>
<li class="toctree-l1"><a class="reference internal" href="#example-for-rst-usage-math-code-etc">11. Example for rst usage (math, code etc)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#example-of-math-citatiion">11.1. Example of math citatiion :</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-of-math-with-latex-as-equation">11.2. Example of math with latex as equation :</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-of-math-with-latex-as-inline-text">11.3. Example of math with latex as inline text :</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-of-bash-code">11.4. Example of bash code :</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-of-cpp-code">11.5. Example of cpp code :</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-of-yaml-code">11.6. Example of yaml code :</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-of-simple-figure">11.7. Example of simple figure :</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ExDEM Variant</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../project_exaDEM/Introduction.html">1. ExaDEM Software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../project_exaDEM/Installation.html">2. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../project_exaDEM/Test_cases.html">3. Test cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../project_exaDEM/Polyhedra.html">4. Polyhedron</a></li>
<li class="toctree-l1"><a class="reference internal" href="../project_exaDEM/Spheres.html">5. Spheres</a></li>
<li class="toctree-l1"><a class="reference internal" href="../project_exaDEM/Fields.html">6. Fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../project_exaDEM/ForceField.html">7. Force Field</a></li>
<li class="toctree-l1"><a class="reference internal" href="../project_exaDEM/NumericalScheme.html">8. Numerical Scheme</a></li>
<li class="toctree-l1"><a class="reference internal" href="../project_exaDEM/Drivers.html">9. Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../project_exaDEM/Analysis.html">10. I/O and Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../project_exaDEM/Parallelization.html">11. Parallelization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../project_exaDEM/Tutorial.html">12. Tutorials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Using exaNBody applications on Adastra</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="adastra.html">1. Installing ExaNB and Your application on Adastra</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Bibliography</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">ExaDEM & ExaNBody</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active"><span class="section-number">1. </span>ExaNBody: Framework for N-Body Simulations on HPC Platforms</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/project_exaNBody/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="exanbody-framework-for-n-body-simulations-on-hpc-platforms">
<h1><span class="section-number">1. </span>ExaNBody: Framework for N-Body Simulations on HPC Platforms<a class="headerlink" href="#exanbody-framework-for-n-body-simulations-on-hpc-platforms" title="Permalink to this heading"></a></h1>
<p>This framework, developed at the French Atomic Agency (CEA), is tailored for N-Body simulations on High-Performance Computing (HPC) platforms. Originally designed for the ExaSTAMP Molecular Dynamics code, it has been extended to cater to various N-Body problems.</p>
<p>Key Characteristics:</p>
<ul class="simple">
<li><p><strong>Language:</strong> Implemented in C++17, leveraging modern language features for efficiency and versatility.</p></li>
<li><dl class="simple">
<dt><strong>Parallelization:</strong>: Hybrid approach integrating:</dt><dd><ul>
<li><p>Vectorization for CPU optimization.</p></li>
<li><p>Thread-parallelization using OpenMP for multi-core architectures.</p></li>
<li><p>GPU-parallelization via CUDA to harness GPU computational power.</p></li>
<li><p>MPI-parallelization for distributed memory systems.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p><strong>Spatial Domain Decomposition:</strong> Utilizes spatial domain decomposition techniques for efficient workload distribution among processors.</p></li>
<li><p><strong>Load Balancing (RCB):</strong> Implements Load Balancing using Recursive Coordinate Bisection (RCB) for optimal task distribution among processing units.</p></li>
<li><p><strong>Parallel IO:</strong> Enables efficient handling of parallel Input/Output operations. Supports checkpoint files, parallel Paraview files, and diagnostics in a parallelized manner.</p></li>
<li><p><strong>In-situ Analysis:</strong> Provides real-time data analysis capabilities during simulation execution, minimizing data movement and storage overhead.</p></li>
</ul>
<section id="exadem-variant">
<h2><span class="section-number">1.1. </span>ExaDEM Variant<a class="headerlink" href="#exadem-variant" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">ExaDEM</span></code> is a software solution in the field of computational simulations. It’s a Discrete Element Method (<code class="docutils literal notranslate"><span class="pre">DEM</span></code>) code developed within the <code class="docutils literal notranslate"><span class="pre">exaNBody</span> <span class="pre">framework</span></code>. This framework provides the basis for DEM functionalities and performance optimizations. A notable aspect of <code class="docutils literal notranslate"><span class="pre">ExaDEM</span></code> is its hybrid parallelization approach, which combines the use of <code class="docutils literal notranslate"><span class="pre">MPI</span></code> (Message Passing Interface) and Threads (<code class="docutils literal notranslate"><span class="pre">OpenMP</span></code>). This combination aims to enhance computation times for simulations, making them more efficient and manageable.</p>
<p>Additionally, <code class="docutils literal notranslate"><span class="pre">ExaDEM</span></code> offers compatibility with <code class="docutils literal notranslate"><span class="pre">MPI``+``GPUs</span></code>, using the <code class="docutils literal notranslate"><span class="pre">CUDA</span></code> programming model (Onika layer). This feature provides the option to leverage <code class="docutils literal notranslate"><span class="pre">GPU</span></code> processing power for potential performance gains in simulations. Written in <code class="docutils literal notranslate"><span class="pre">C++17</span></code>, <code class="docutils literal notranslate"><span class="pre">ExaDEM</span></code> is built on a contemporary codebase. It aims to provide researchers and engineers with a tool for adressing <code class="docutils literal notranslate"><span class="pre">DEM</span></code> simulations.</p>
</section>
<section id="exasph-variant">
<h2><span class="section-number">1.2. </span>ExaSPH Variant<a class="headerlink" href="#exasph-variant" title="Permalink to this heading"></a></h2>
</section>
<section id="exastamp-variant">
<h2><span class="section-number">1.3. </span>ExaSTAMP Variant<a class="headerlink" href="#exastamp-variant" title="Permalink to this heading"></a></h2>
</section>
</section>
<section id="installing-exanb">
<h1><span class="section-number">2. </span>Installing ExaNB<a class="headerlink" href="#installing-exanb" title="Permalink to this heading"></a></h1>
<p>To proceed with the installation, your system must meet the minimum prerequisites. The first step involves the installation of exaNBody:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/Collab4exaNBody/exaNBody.git
mkdir<span class="w"> </span>build-exaNBody/<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nb">cd</span><span class="w"> </span>build-exaNBody/
cmake<span class="w"> </span>../exaNBody/<span class="w"> </span>-DCMAKE_INSTALL_PREFIX<span class="o">=</span>path_to_install
make<span class="w"> </span>install
<span class="nb">export</span><span class="w"> </span><span class="nv">exaNBody_DIR</span><span class="o">=</span>path_to_install
</pre></div>
</div>
</section>
<section id="n-body-background">
<h1><span class="section-number">3. </span>N-Body Background<a class="headerlink" href="#n-body-background" title="Permalink to this heading"></a></h1>
<section id="n-body-methods">
<h2><span class="section-number">3.1. </span>N-body methods<a class="headerlink" href="#n-body-methods" title="Permalink to this heading"></a></h2>
<p>N-body methods encompass a variety of techniques used to model the behavior and interactions of a set of particles over time.
These methods consist in solving Newton’s equation of motion f = ma for each particle at each time step, where f corresponds to the sum of the forces applied to the particle, a its acceleration and m its mass.
The forces are deduced from the interactions between particles according to their types, i.e. contact, short-range, or long-range interactions, and external forces applied to the sample (i.e. gravity).
Velocities are then deduced from the accelerations and subsequently used to update the particle positions at the next time step.
This process is repeated, typically with a fixed time step ∆t, according to an integration scheme4 until the desired duration is reached.
The collection of particle configurations over time allows to study a wide range of phenomena, from granular media movements, with the Discrete Element Method (Dem), to material crystal plasticity at the atomic scale using Molecular Dynamics (Md), going up to the galaxy formation with the Smoothed-Particle Hydrodynamics (Sph).</p>
</section>
<section id="n-body-simulation-codes">
<h2><span class="section-number">3.2. </span>N-body simulation codes<a class="headerlink" href="#n-body-simulation-codes" title="Permalink to this heading"></a></h2>
<p>The development of a N-body code is led by the need to figure out the neighborhood of a given particle for every timestep in order to process interactions of different kinds.</p>
<p>Particle interactions can be categorized as short-range and long-range.
Short-range interactions are considered negligible beyond a specified cut-off radius.
To optimize calculations, neighboring particle detection algorithms are employed to eliminate unnecessary computations with distant particles.
Each N-Body method employs a wide variety of short-range interactions that capture different particle physics.
For example, visco-elastic contacts in Discret Element Method follow Hooke’s law or Hertz law to model contact elasticity between rigid particles, while pair potentials like Lennard-Jones or Morse are used for gas or liquid atom interactions in classical Md. Long-range interactions, on the other hand, can sometimes not be neglected and result in algorithmic complexity of O(N 2 ).
Such interactions, like gravitation in astrophysics, or electrostatic forces in Molecular Dynamics, are typically modeled using the Ewald summation method.
Fortunately, calculation approaches such as the fast multipole method can achieve a complexity of O(N ), thanks to an octree structure, and can be efficiently parallelized.
Although this paper primarily focuses on short-range interactions, both types of interaction can be dealt with in exaNBody.</p>
<p>Neighbor lists are built, using different strategies, to shorten the process of finding out the neighbors of a particle within the simulation domain.
It helps optimizing the default algorithm having a complexity of O(N^2) that tests every pair of particles (if N is the number of particles).
The most common strategy to deal with any kind of simulation (static or dynamic, homogeneous and heterogeneous density) is a fusion between the linked-cell method, see figure 2, and the Verlet list, see figure 2 method.
The combination of these methods has a complexity of O(N) and a refresh rate that depends on the displacement of the fastest particle.
This algorithm is easily thread-parallelized. Others less-used neighbor search strategies have been developed to address specific simulations</p>
<figure class="align-center" id="id1">
<a class="reference internal image-reference" href="../_images/Verlet.png"><img alt="map to buried treasure" src="../_images/Verlet.png" style="width: 250pt;" /></a>
<figcaption>
<p><span class="caption-text">Figure 1: A method for building neighbor lists using the Verlet lists. <cite>rcut</cite> is the radius cut-off and <cite>rVerlet</cite> is the radius of Verlet.</span><a class="headerlink" href="#id1" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<figure class="align-center" id="id2">
<a class="reference internal image-reference" href="../_images/LC.png"><img alt="map to buried treasure" src="../_images/LC.png" style="width: 250pt;" /></a>
<figcaption>
<p><span class="caption-text">Figure 2: A method for building neighbor lists using linked cells. <cite>rcut</cite> is the radius cut-off.</span><a class="headerlink" href="#id2" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Domain decomposition is usually employed in N-Body methods to address distributed memory parallelization, assigning one subdomain to each MPI process.
This implies the addition of ghost areas (replicated particles) around subdomains to ensure each particle has access to its neighborhood.
Over time, many algorithms have been designed to improve load-balancing such as: Recursive Coordinate Bisection (RCB), the Recursive Inertial Bisection (RIB), the Space Filling Curve (SFC), or graph method with ParMETIS.
Note that the library Zoltan gathers the most popular methods.
To ease neighbor list construction (i.e. employing the linked-cell method), the simulation domain is described as a cartesian grid of cells, each of which containing embedded particles.
Each subdomain then consists in a grid of entire cells assigned to one Mpi process.
In contrast, concurent iteration over the cells of one subdomain’s grid provides the basis for thread parallelization at the NUMA node level.</p>
<p>Commonalities are shared across N-body simulation codes, such as numerical schemes, neighbor particle detection, or short/long-range interactions.
The computation time dedicated to interaction and force calculations can be significant (over 80% of the total time) depending on the studied hpenomenon complexity.
Additional factors, such as neighbor lists construction computational cost, can impact overall simulation time.
For dynamic simulations involving rapidly moving particles and computationally inexpensive interactions, more than 50% of the total time may be spent on neighbor list construction.
The computationally intensive sections of the code vary depending on methods and phenomena studied, requiring optimizations such as:</p>
<blockquote>
<div><ul class="simple">
<li><p>MPI parallelization</p></li>
<li><p>Vectorization</p></li>
<li><p>Multi-threading</p></li>
<li><p>GPU usage</p></li>
</ul>
</div></blockquote>
</section>
</section>
<section id="software-stack-of-exanbody">
<h1><span class="section-number">4. </span>Software stack of ExaNBody<a class="headerlink" href="#software-stack-of-exanbody" title="Permalink to this heading"></a></h1>
<section id="software-stack-layers">
<h2><span class="section-number">4.1. </span>Software Stack Layers:<a class="headerlink" href="#software-stack-layers" title="Permalink to this heading"></a></h2>
<ol class="arabic">
<li><p>External Libraries: This layer encompasses external dependencies utilized by the software. These libraries are leveraged to access functionalities that are not internally developed, enhancing the overall capabilities of the system.</p>
<blockquote>
<div><ul class="simple">
<li><p>HPC Libraries: High-Performance Computing (HPC) libraries serve as powerful tools within the software stack, providing optimized routines and functionalities specifically designed for high-computational tasks.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Low-Level and Runtime Support (Onika): Foundational infrastructure and runtime support are provided by this layer. Onika serves as the backbone, offering essential utilities for the execution and management of the software. It’s important to note that ongoing efforts are directed towards integrating frameworks like OpenMP or CUDA.</p></li>
<li><p>N-Body Framework: Positioned at the core of the software stack, the N-Body Framework proposes a large variety of N-Body features to build efficiently N-Body simulation such as traditionnal integration schemes, IO, or partiionning methods.</p></li>
<li><p>Application Layer: This layer encapsulates the specific applications built upon the software stack. It provides the interface for users to interact with the functionalities offered by the stack and serves as the platform for N-Body application-specific implementations and functionalities.</p></li>
</ol>
<p><a class="reference internal" href="../_images/software_stack.png"><img alt="exanb-st" src="../_images/software_stack.png" style="width: 500pt;" /></a></p>
</section>
<section id="guidelines-for-operators">
<h2><span class="section-number">4.2. </span>Guidelines for operators:<a class="headerlink" href="#guidelines-for-operators" title="Permalink to this heading"></a></h2>
<ul class="simple">
<li><p>Common Operators: These operators serve as N-Body fundamental operations utilized across various components of the software, facilitating consistent functionality and reducing redundancy.</p></li>
<li><p>Application-Specific Operators: Tailored operators designed to cater to the unique requirements of specific applications built on top of the software stack.</p></li>
<li><p>Mutualization: This process involves the consolidation and centralization of specific operators shared by multiple applications. It aims to optimize resources and streamline the execution of these shared functionalities.</p></li>
<li><p>Specific Operators Shared Among Applications: For increased efficiency and ease of access, specific operators that are shared among multiple applications are centralized within exaNBody. This consolidation not only ensures optimized utilization but also simplifies management and maintenance, benefiting all associated applications.</p></li>
</ul>
</section>
</section>
<section id="performance-and-portability">
<h1><span class="section-number">5. </span>Performance and portability<a class="headerlink" href="#performance-and-portability" title="Permalink to this heading"></a></h1>
<p>The complex and ever-changing architectures of modern supercomputers make it difficult to maintain software performance. exaNBody aims at providing performance portability and sustainability on those supercomputers with robust domain decomposition, automated inter-process communications algorithms, adaptable particle data layout, and a set of hybrid (CPU/GPU) parallelization
templates specialized for N-Body problems.</p>
<section id="application-level-specialization">
<h2><span class="section-number">5.1. </span>Application level specialization<a class="headerlink" href="#application-level-specialization" title="Permalink to this heading"></a></h2>
<p>First of all, the internal units to be used are specified as well as the physical quantities to be stored as particle attributes.
These quantities (or fields), are defined using a symbolic name associated with a type, e.g. velocity as a 3D vector.
A field set is a collection of declared fields.
One of the available field sets is selected and used at runtime, depending on simulation specific needs.
As depicted in figure below, particles are dispatched in cells of a cartesian grid spanning the simulation domain.
In short, the data structure containing all particles’ data will be shaped as a cartesian grid of cells, each cell containing all fields for all particles it (geometrically) contains.
More specifically, the reason why fields and field sets are defined at compile time is that particle data storage at the cell level is handled via a specific structure guaranteeing access performance and low memory footprint.</p>
</section>
<section id="spatial-domain-decomposition-and-inter-process-communications">
<h2><span class="section-number">5.2. </span>Spatial domain decomposition and inter-process communications<a class="headerlink" href="#spatial-domain-decomposition-and-inter-process-communications" title="Permalink to this heading"></a></h2>
<p>The coarsest parallelization level can become the main bottleneck due to network latencies and load imbalance issues.
To take advantage of this first level of parallelization, the simulation domain is divided into subdomains using an recursive coordinate bisection (RCB) algorithm, as depicted in figure below, assigning one subdomain to each MPI process.</p>
<figure class="align-center" id="id3">
<a class="reference internal image-reference" href="../_images/inter_process_communications.png"><img alt="map to buried treasure" src="../_images/inter_process_communications.png" style="width: 450pt;" /></a>
<figcaption>
<p><span class="caption-text">Figure 1: Overview of domain decomposition and inter process communications in exaNBody framework.</span><a class="headerlink" href="#id3" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>This is achieved thanks to three main components: cell cost estimator, RCB domain decomposition, and particle migration.
Particle migration can be used as-is by any N-Body application, thanks to the underlying generic particle data storage.
It supportsheavily multi-threaded, large scale, simulations while lowering peak memory usage.
Additionally, the migration algorithm is also customizable to fit specific application needs, keeping unchanged the core implementation.
For instance, molecualr dynamics simulations may transport per-cell data fields and discret element method simulations may migrate friction information related to pair of particles.
Finally, ghost particle updates are available to any N-Body application, via customizable components.</p>
</section>
<section id="intra-node-parallelization-api">
<h2><span class="section-number">5.3. </span>Intra-node parallelization API<a class="headerlink" href="#intra-node-parallelization-api" title="Permalink to this heading"></a></h2>
<p>This API is available in exaNBody to help developers express parallel computations within a MPI process.
This API offers a set of parallelization templates associated with three types of computation kernels:</p>
<blockquote>
<div><ul class="simple">
<li><p>Local calculations on a particle (such as resetting force operator)</p></li>
<li><p>calculations coupled with reduction across all particles (such as getting the total number of particles or the current temperature)</p></li>
<li><p>calculations involving each particle and its neighbors (such as computing potential forces in molecular dynamics or contact forces in discret element method)</p></li>
</ul>
</div></blockquote>
<p>When a developer injects a compute function into these templates, computation may be routed to CPU or GPU, as illustrated in figure below.</p>
<figure class="align-center" id="id4">
<a class="reference internal image-reference" href="../_images/compute_kernel_sample.png"><img alt="map to buried treasure" src="../_images/compute_kernel_sample.png" style="width: 450pt;" /></a>
<figcaption>
<p><span class="caption-text">Figure 2: Example of a particle centered computation executable on both COU and GPU. Three ingredients: a user functor (the kernel), static execution properties (via traits specialization), a ready to use parallelization function template.</span><a class="headerlink" href="#id4" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>While thread parallelization on the CPU is powered by OpenMP, Cuda is employed to execute the computation kernel on the Gpu, using the same provided function.
The main difference between the two execution modes is that each cell is a unitary work unit for a single thread in OpenMP context but it is processed by a block of threads in Cuda.
Those two parallelization levels (multi-core and GPU) are easily accessible to developers thanks to the execution support layer of Onika.
Onika is the low-level software interface that powers exaNBody building blocks.
It is responsible for aforementioned data containers, memory management (unified with GPU), and it is the foundation for hybrid execution abstraction layer.</p>
</section>
<section id="particle-data-layout-and-auxiliary-data-structures">
<h2><span class="section-number">5.4. </span>Particle data layout and auxiliary data structures<a class="headerlink" href="#particle-data-layout-and-auxiliary-data-structures" title="Permalink to this heading"></a></h2>
<p>These two points are two essential features to maximize performance at the NUMA node level.
In exaNBody, particle data are packed independently in each cell using a container specifically designed to match both CPU’s SIMD and GPU’s thread blocks requirements concerning data alignment and vectorization friendly padding.
This generic container, available in ONIKA toolbox, not only adapts to specific hardware characteristics at compile time, but ensures minimal memory footprint with as low as 16 bytes overhead per cell regardless of the number of data fields, allowing for very large and sparse simulation domains.
N-Body simulations also heavily depend on particles’ neighbors search algorithm and storage structure.
The search usually leverages the grid of cell structure to speed up the process, and neighbors lists data structure holds information during several iterations.
However, depending on the simulation, particles may move rapidly while their distribution may be heterogeneously dense.
Those two factors respectively impact neighbor list update frequency and its memory footprint.
On the one hand, exaNBody takes advantage of an Adaptive Mesh Refinement (AMR) grid to accelerate (frequent) neighbor list reconstructions.
On the other hand, a compressed neighbor list data structure saves up to 80% of memory (compared to uncompressed lists) while still ensuring fast access from both the CPU and the GPU.</p>
</section>
<section id="flexible-and-user-friendly-construction-of-n-body-simulations">
<h2><span class="section-number">5.5. </span>Flexible and user friendly construction of N-Body simulations<a class="headerlink" href="#flexible-and-user-friendly-construction-of-n-body-simulations" title="Permalink to this heading"></a></h2>
<p>A crucial aspect for software sustainability is to maintain performance over time while managing software complexity and evolution.
Complex and rapidly evolving scientific software often encounter common pitfalls, such as code duplication, uncontrolled increase in software inter-dependencies, and obscure data/control
flows. This observation has led us to develop our component-based model to avoid these pitfalls.
In our model, individual software components are implemented using C++17 and are application structure oblivious, meaning they only know their input and output data flows. Application obliviousness is a crucial aspect of the present design, promoting reusability while preventing uncontrolled growth of internal software dependencies.
Each component is developed as a class, inheriting from a base class OperatorNode and explicitly declares its input and output slots (data flow connection points).
Once compiled, these components are hierarchically assembled at runtime using a Sequential Task Flow (STF), with a YAML syntax, as shown in figure below.</p>
<figure class="align-center" id="id5">
<a class="reference internal image-reference" href="../_images/yaml_components.png"><img alt="map to buried treasure" src="../_images/yaml_components.png" style="width: 450pt;" /></a>
<figcaption>
<p><span class="caption-text">Figure 3: Illustrative sample of components assembly using YAML description. 1) C++ developed components are assembled and connected in the manner of a STF, creating a batch component. 2) and 3) illustrate batch components aggregation to higher and higher level components, up to full simulation task flow.</span><a class="headerlink" href="#id5" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>A set of base components are already available to developers, embedded within exaNBody, such as: common computations, checkpoint/restart, visualization and In-Situ analytics, allowing developers to focus on their application specific components.
We also observed that this component based approach not only prevents some development pitfalls, but enables various simulation code structures.
YAML formatted component configuration makes it simple for a user to amend or fine tune the simulation process.
For instance it can be used to change the numerical scheme or even to insert In-Situ analysis components at specific stages of the simulation process, leveraging In-Situ processing to limit disk I/O.
Finally, this component based splitting of the code gives exaNBody the opportunity to provide integrated profiling features that automatically give meaningful performance metrics for each part of the simulation.
It allows the user to access computation time spent on CPU and GPU, as well as imbalance indicator.
It can also interoperate with nSight System from NVIDIA and summarize memory footprint with detailed consumption.</p>
</section>
</section>
<section id="algorithm-patterns">
<h1><span class="section-number">6. </span>Algorithm Patterns<a class="headerlink" href="#algorithm-patterns" title="Permalink to this heading"></a></h1>
<p>This is Developer Documentation.</p>
<p>The aim of this section is to explain to developers the tools used in exaNBody to propose default parallel algorithms. For this purpose, we will describe the 4 main algorithmic patterns:</p>
<ul class="simple">
<li><p><cite>block_parallel_for</cite>: exposes a simple parallelization scheme (like a parallel for in OpenMP), but with a notion of “thread blocks” and the possibility of asynchronous execution. It is defined directly in the Onika layer, as it is not specific to particle systems.</p></li>
<li><p><cite>compute_cell_particles</cite>: performs a parallel processing on all particles contained within a grid (Grid type pattern).</p></li>
<li><p><cite>reduce_cell_particles</cite>: performs an operation on each particle returning a value, the values obtained being reduced to a single one (e.g., a sum).</p></li>
<li><p><cite>compute_cell_particle_pairs</cite>: the most important and most used pattern, allows calculations on particles and their neighbors.</p></li>
</ul>
<p>Guidelines:</p>
<ul class="simple">
<li><p>Support hybrid execution, automatically directing calculations either to the <cite>CPU</cite> cores or to the <cite>GPU</cite>.</p></li>
<li><p>Avoid code duplication between components.</p></li>
<li><p>Avoid the complexities of setting up <cite>OpenMP</cite>/<cite>CUDA</cite> parallelism.</p></li>
<li><p>Allow asynchronous parallel operations (with results retrieved later in the code).</p></li>
<li><p>Automatically adapt to the different <cite>OpenMP</cite> parallelism modes supported by the component system (simple, nested, and task-based).</p></li>
<li><p>Facilitate the implementation of a single computation function for both <cite>CPU</cite> and <cite>GPU</cite>.</p></li>
<li><p>Manage dynamic load balancing among the <cite>SMs</cite> of the <cite>GPUs</cite> themselves.</p></li>
</ul>
<section id="block-parallel-for">
<h2><span class="section-number">6.1. </span>Block Parallel For<a class="headerlink" href="#block-parallel-for" title="Permalink to this heading"></a></h2>
<p>This construction is the most rudimentary; it is equivalent to an <cite>OpenMP</cite> parallel for directive but with many additional possibilities. We will look at a step-by-step example where a fixed value is added to all elements of an array of arrays. The example on a two-dimensional array demonstrates the use of two-level multi-threaded parallelism we have discussed, which resembles a bit the array of cells, each containing a set of particles typically processed in exaNBody.</p>
<section id="basic-usage">
<h3><span class="section-number">6.1.1. </span>Basic usage<a class="headerlink" href="#basic-usage" title="Permalink to this heading"></a></h3>
<p>Before calling <cite>block_parallel_for</cite>, it is necessary to define the functor (the calculation function) that will be applied in parallel to our data.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">exaStamp</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">exanb</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// a functor = function applied in parallel</span>
<span class="w">  </span><span class="c1">// it is defined by a class (or struct) with the call operator ()</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">ValueAddFunctor</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">**</span><span class="n">array</span><span class="p">;</span><span class="w">      </span><span class="c1">// our 2D array</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">columns</span><span class="p">;</span><span class="w">      </span><span class="c1">// number of columns in our array</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">m_value_to_add</span><span class="p">;</span><span class="w"> </span><span class="c1">// value to add</span>

<span class="w">    </span><span class="n">ONIKA_HOST_DEVICE_FUNC</span><span class="w">       </span><span class="c1">// works on CPU and GPU</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w">  </span><span class="c1">// call operator with i in [0;n[</span>
<span class="w">    </span><span class="p">{</span><span class="w">                            </span><span class="c1">// a whole block (all its threads) execute iteration i</span>
<span class="w">      </span><span class="n">ONIKA_CU_BLOCK_SIMD_FOR</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">columns</span><span class="p">)</span><span class="w">  </span><span class="c1">// parallelization among the threads of the current block</span>
<span class="w">      </span><span class="p">{</span><span class="w">                                               </span><span class="c1">// for iterations on j in [0;columns[</span>
<span class="w">        </span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">m_value_to_add</span><span class="p">;</span><span class="w">               </span><span class="c1">// each thread executes 0, 1, or multiple iterations of j</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p><cite>ONIKA_CU_BLOCK_SIMD_FOR</cite>: Defines a macro that facilitates the use of the second level of parallelism within threads of the same <cite>CUDA</cite> block.</p></li>
<li><p>Usage:</p>
<ul>
<li><p>GPU :Ensures that the functor’s code is executed across all threads within a <cite>CUDA</cite> block with consistent iteration index <cite>i</cite>. When compiled for the <cite>GPU</cite>, it distributes iterations based on <cite>ONIKA_CU_BLOCK_SIZE</cite> and <cite>ONIKA_CU_THREAD_IDX</cite>.</p></li>
<li><p>CPU: On the host, this construct transforms into a straightforward for loop. However, on the host, the loop includes the <cite>OpenMP</cite> directive #pragma omp simd for, ensuring loop vectorization, even with only one  <cite>CPU</cite> thread per block, provided <cite>CPU</cite> and compiler support is available.</p></li>
</ul>
</li>
</ul>
<p>Next, we need to inform the compiler whether our functor is compatible with <cite>CUDA</cite>. In some situations, our code may have a strong incompatibility (such as calling a non-compatible library) that would prevent it from compiling correctly with the nvcc layer. This needs to be known at compile time (not just at runtime) because otherwise, compilation errors would occur.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">onika</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">parallel</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">BlockParallelForFunctorTraits</span><span class="o">&lt;</span><span class="n">ValueAddFunctor</span><span class="o">&gt;</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">CudaCompatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// or false to prevent the code from being compiled with CUDA</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The final step is to launch the parallel operation in the code of our component:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">exaStamp</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">MyValueAdd</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">OperatorNode</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">ADD_SLOT</span><span class="p">(</span><span class="n">Array2D</span><span class="p">,</span><span class="w"> </span><span class="n">my_array</span><span class="p">,</span><span class="w"> </span><span class="n">INPUT</span><span class="p">,</span><span class="w"> </span><span class="n">REQUIRED</span><span class="p">);</span>
<span class="w">    </span><span class="n">ADD_SLOT</span><span class="p">(</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">my_value</span><span class="p">,</span><span class="w"> </span><span class="n">INPUT</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">execute</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">final</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">ValueAddFunctor</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">my_array</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span><span class="w">     </span><span class="c1">// data of our array (double**), initializes the &#39;array&#39; member of our functor</span>
<span class="w">                             </span><span class="p">,</span><span class="w"> </span><span class="n">my_array</span><span class="o">-&gt;</span><span class="n">columns</span><span class="p">()</span><span class="w">  </span><span class="c1">// number of columns in our 2D array</span>
<span class="w">                             </span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">my_value</span><span class="w"> </span><span class="p">};</span><span class="w">         </span><span class="c1">// value to add to the elements of the array</span>
<span class="w">      </span><span class="c1">// Launching the parallel operation, which can execute on GPU if the execution context allows</span>
<span class="w">      </span><span class="n">onika</span><span class="o">::</span><span class="n">parallel</span><span class="o">::</span><span class="n">block_parallel_for</span><span class="p">(</span><span class="n">my_array</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">()</span><span class="w">             </span><span class="c1">// number of iterations, parallelize at the first level over rows</span>
<span class="w">                                         </span><span class="p">,</span><span class="w"> </span><span class="n">func</span><span class="w">                         </span><span class="c1">// the function to call in parallel</span>
<span class="w">                                         </span><span class="p">,</span><span class="w"> </span><span class="n">parallel_execution_context</span><span class="p">()</span><span class="w"> </span><span class="c1">// returns the parallel execution context associated with this component</span>
<span class="w">                                         </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="asynchrone-usage">
<h3><span class="section-number">6.1.2. </span>Asynchrone usage<a class="headerlink" href="#asynchrone-usage" title="Permalink to this heading"></a></h3>
<p>In the following example, we are still using the simplest version of <cite>block_parallel_for</cite>. Optional parameters can be added to control asynchronicity or even disable execution on the <cite>GPU</cite>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">exaStamp</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">MyValueAdd</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">OperatorNode</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">ADD_SLOT</span><span class="p">(</span><span class="n">Array2D</span><span class="p">,</span><span class="w"> </span><span class="n">my_array</span><span class="p">,</span><span class="w"> </span><span class="n">INPUT</span><span class="p">,</span><span class="w"> </span><span class="n">REQUIRED</span><span class="p">);</span>
<span class="w">    </span><span class="n">ADD_SLOT</span><span class="p">(</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">my_value</span><span class="p">,</span><span class="w"> </span><span class="n">INPUT</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">execute</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">final</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cols</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_array</span><span class="o">-&gt;</span><span class="n">columns</span><span class="p">();</span>
<span class="w">      </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_array</span><span class="o">-&gt;</span><span class="n">rows</span><span class="p">();</span>
<span class="w">      </span><span class="kt">bool</span><span class="w"> </span><span class="n">enable_gpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">cols</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w">     </span><span class="c1">// enable GPU execution only if the matrix has more than 1000 values</span>
<span class="w">      </span><span class="n">ValueAddFunctor</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">my_array</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">my_value</span><span class="w"> </span><span class="p">};</span>
<span class="w">      </span><span class="k">auto</span><span class="w"> </span><span class="n">control</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">onika</span><span class="o">::</span><span class="n">parallel</span><span class="o">::</span><span class="n">block_parallel_for</span><span class="p">(</span>
<span class="w">                       </span><span class="n">rows</span>
<span class="w">                     </span><span class="p">,</span><span class="w"> </span><span class="n">func</span>
<span class="w">                     </span><span class="p">,</span><span class="w"> </span><span class="n">parallel_execution_context</span><span class="p">()</span>
<span class="w">                     </span><span class="p">,</span><span class="w"> </span><span class="n">enable_gpu</span><span class="w">                    </span><span class="c1">// enable or disable GPU execution</span>
<span class="w">                     </span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="w">                          </span><span class="c1">// request asynchronous execution</span>
<span class="w">                     </span><span class="p">);</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Meanwhile, the parallel operation is executing...&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">      </span><span class="n">control</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">();</span><span class="w">                               </span><span class="c1">// wait for the operation to complete and results to be ready to read</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Parallel operation completed!&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the execution context allows it, the parallel operation will proceed in the background, occupying either the free threads (other than those executing this code) or the <cite>GPU</cite>. This can be very useful, especially for overlapping computations and <cite>MPI</cite> message sends.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The operation is asynchronous only if the execution context permits it. Otherwise, it will proceed synchronously and complete before the <cite>block_parallel_for</cite> function returns. In such cases, calling <cite>control-&gt;wait()</cite> will simply have no effect.</p>
</div>
</section>
</section>
<section id="compute-cell-particles">
<h2><span class="section-number">6.2. </span>Compute Cell Particles<a class="headerlink" href="#compute-cell-particles" title="Permalink to this heading"></a></h2>
<p>This is the first specialized algorithmic pattern for particle systems. Therefore, it can only be applied to an instantiation of the <cite>Grid</cite> type from <cite>exaNBody</cite>. This pattern is the simplest; it will perform an independent operation in parallel on all particles in the system. To understand how this works in the implementation of a component, the following code presents a fully commented example aimed at increasing the velocity of all particles by a constant vector.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exanb/core/operator.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exanb/core/operator_slot.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exanb/core/operator_factory.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exanb/core/make_grid_variant_operator.h&gt;</span><span class="c1"> // because we use make_grid_variant_operator for component registration</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exanb/compute/compute_cell_particles.h&gt;</span><span class="c1">  // provides the compute_cell_particles function</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">exaStamp</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">AddVec3Functor</span><span class="w">        </span><span class="c1">// our functor, adds a vector to the 3 components of particle velocity</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Vec3d</span><span class="w"> </span><span class="n">vec_to_add</span><span class="p">;</span><span class="w">    </span><span class="c1">// functor parameter: the velocity to add</span>

<span class="w">    </span><span class="n">ONIKA_HOST_DEVICE_FUNC</span>
<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="p">()(</span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">vy</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">vz</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="c1">// parameters defined by compute_fields_t declared below</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">vx</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">vec_to_add</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w">  </span><span class="c1">// perform the desired operation</span>
<span class="w">      </span><span class="n">vy</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">vec_to_add</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w">  </span><span class="c1">// particle attributes are passed by reference (&amp;), so they can be modified</span>
<span class="w">      </span><span class="n">vz</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">vec_to_add</span><span class="p">.</span><span class="n">z</span><span class="p">;</span><span class="w">  </span><span class="c1">// here, we only need to implement the local operation on the particle, without worrying about thread block levels</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>
<span class="p">}</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">exanb</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">ComputeCellParticlesTraits</span><span class="o">&lt;</span><span class="n">exaStamp</span><span class="o">::</span><span class="n">AddVec3Functor</span><span class="o">&gt;</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">RequiresBlockSynchronousCall</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// no collaboration between threads of the same block</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">CudaCompatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w">                </span><span class="c1">// compatible with Cuda (thanks to ONIKA_HOST_DEVICE_FUNC usage)</span>
<span class="w">  </span><span class="p">};</span>
<span class="p">}</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">exaStamp</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="o">&lt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">GridT</span><span class="w">                                                        </span><span class="c1">// our component adapts to any grid type</span>
<span class="w">          </span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AssertGridHasFields</span><span class="o">&lt;</span><span class="n">GridT</span><span class="p">,</span><span class="n">field</span><span class="o">::</span><span class="n">_vx</span><span class="p">,</span><span class="n">field</span><span class="o">::</span><span class="n">_vy</span><span class="p">,</span><span class="n">field</span><span class="o">::</span><span class="n">_vz</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="c1">// as long as particles have the vx, vy, and vz attributes</span>
<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">ParticleVelocityAdd</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">OperatorNode</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">      </span><span class="n">ADD_SLOT</span><span class="p">(</span><span class="n">Vec3d</span><span class="p">,</span><span class="w"> </span><span class="n">vec</span><span class="p">,</span><span class="w"> </span><span class="n">INPUT</span><span class="p">,</span><span class="w"> </span><span class="n">REQUIRED</span><span class="p">);</span><span class="w">    </span><span class="c1">// vector to add to particle velocities</span>
<span class="w">      </span><span class="n">ADD_SLOT</span><span class="p">(</span><span class="n">GridT</span><span class="p">,</span><span class="w"> </span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">INPUT_OUTPUT</span><span class="p">);</span><span class="w">      </span><span class="c1">// grid containing cells and all particles within the sub-domain</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">execute</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">final</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">using</span><span class="w"> </span><span class="n">compute_fields_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FieldSet</span><span class="o">&lt;</span><span class="n">field</span><span class="o">::</span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">vy</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">vz</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// fields on which our functor operates</span>
<span class="w">      </span><span class="n">AddVec3Functor</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">*</span><span class="n">vec</span><span class="w"> </span><span class="p">};</span><span class="w">                                     </span><span class="c1">// instantiate the functor with the velocity provided as input to the component</span>
<span class="w">      </span><span class="n">compute_cell_particles</span><span class="p">(</span><span class="o">*</span><span class="n">grid</span><span class="w">                    </span><span class="c1">// grid containing particles</span>
<span class="w">                            </span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="w">                    </span><span class="c1">// do not apply our function in ghost zones</span>
<span class="w">                            </span><span class="p">,</span><span class="w"> </span><span class="n">func</span><span class="w">                     </span><span class="c1">// the functor to apply</span>
<span class="w">                            </span><span class="p">,</span><span class="w"> </span><span class="n">compute_fields_t</span><span class="p">{}</span><span class="w">       </span><span class="c1">// attributes on which to compute ⇒ defines the functor&#39;s call parameters</span>
<span class="w">                            </span><span class="p">,</span><span class="w"> </span><span class="n">parallel_execution_context</span><span class="p">()</span><span class="w"> </span><span class="c1">// component&#39;s parallel execution context</span>
<span class="w">                            </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="c1">// component registration</span>
<span class="w">  </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">GridT</span><span class="o">&gt;</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">ParticleVelocityAddTmpl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ParticleVelocityAdd</span><span class="o">&lt;</span><span class="n">GridT</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="n">CONSTRUCTOR_FUNCTION</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">OperatorNodeFactory</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">register_factory</span><span class="p">(</span><span class="s">&quot;add_velocity&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">make_grid_variant_operator</span><span class="o">&lt;</span><span class="n">ParticleVelocityAddTmpl</span><span class="o">&gt;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="reduce-cell-particles">
<h2><span class="section-number">6.3. </span>Reduce Cell Particles<a class="headerlink" href="#reduce-cell-particles" title="Permalink to this heading"></a></h2>
<p>This algorithm pattern is very similar to the previous one, but it allows for computing the reduction of a calculation result across all particles. As we will see in the commented example below, the usage of this construction will be very similar to <cite>compute_cell_particles</cite> with one important exception: the functor can be called in multiple ways (multiple implementations of the operator () are possible). This reflects the need to perform reduction in three stages for performance reasons: local reduction within each thread, reduction of partial sums computed by threads within the same thread block, and finally the overall reduction that sums the partial contributions from different thread blocks.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exanb/core/operator.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exanb/core/operator_slot.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exanb/core/operator_factory.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exanb/core/make_grid_variant_operator.h&gt;</span><span class="c1"> // because we use make_grid_variant_operator for component registration</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exanb/compute/reduce_cell_particles.h&gt;</span><span class="c1">   // provides the reduce_cell_particles function</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">exaStamp</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">ReduceVec3NormFunctor</span><span class="w"> </span><span class="c1">// our functor calculates the sum of norms of forces</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">ONIKA_HOST_DEVICE_FUNC</span><span class="w">                                    </span><span class="c1">// operator for local reduction within a thread</span>
<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="p">()(</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">sum_norm</span><span class="w">                </span><span class="c1">// reference to accumulate contributions</span>
<span class="w">                           </span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">fx</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">fy</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">fz</span><span class="w">  </span><span class="c1">// particle force, parameters determined by reduce_fields_t declared below</span>
<span class="w">                           </span><span class="p">,</span><span class="w"> </span><span class="n">reduce_thread_local_t</span><span class="w">            </span><span class="c1">// phantom parameter to differentiate call forms (here local thread reduction)</span>
<span class="w">                           </span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">sum_norm</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="w"> </span><span class="n">fx</span><span class="o">*</span><span class="n">fx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fy</span><span class="o">*</span><span class="n">fy</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fz</span><span class="o">*</span><span class="n">fz</span><span class="w"> </span><span class="p">);</span><span class="w">              </span><span class="c1">// compute norm and add contribution</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">ONIKA_HOST_DEVICE_FUNC</span><span class="w">                          </span><span class="c1">// operator for internal reduction within a thread block to a single block value</span>
<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="p">()(</span><span class="w"> </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">sum_norm</span><span class="w">       </span><span class="c1">// reference to accumulate contributions from threads within the block</span>
<span class="w">                           </span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">other_sum</span><span class="w">       </span><span class="c1">// one of the partial sums to accumulate</span>
<span class="w">                           </span><span class="p">,</span><span class="w"> </span><span class="n">reduce_thread_block_t</span><span class="w">  </span><span class="c1">// indicates block-level reduction</span>
<span class="w">                           </span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">ONIKA_CU_ATOMIC_ADD</span><span class="p">(</span><span class="w"> </span><span class="n">sum_norm</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">other_sum</span><span class="w"> </span><span class="p">);</span><span class="w">  </span><span class="c1">// atomic addition function (thread-safe), works in both CUDA and CPU context</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">ONIKA_HOST_DEVICE_FUNC</span><span class="w">                       </span><span class="c1">// operator for reduction across all thread blocks</span>
<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="p">()(</span><span class="w"> </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">sum_norm</span><span class="w">    </span><span class="c1">// reference to global result</span>
<span class="w">                           </span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">other_sum</span><span class="w">    </span><span class="c1">// contribution from one block to add</span>
<span class="w">                           </span><span class="p">,</span><span class="w"> </span><span class="n">reduce_global_t</span><span class="w">     </span><span class="c1">// indicates final reduction</span>
<span class="w">                           </span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">ONIKA_CU_ATOMIC_ADD</span><span class="p">(</span><span class="w"> </span><span class="n">sum_norm</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">other_sum</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>
<span class="p">}</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">exanb</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">ReduceCellParticlesTraits</span><span class="o">&lt;</span><span class="n">exaStamp</span><span class="o">::</span><span class="n">ReduceVec3NormFunctor</span><span class="o">&gt;</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">RequiresBlockSynchronousCall</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// does not use intra-block thread collaboration</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">RequiresCellParticleIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w">    </span><span class="c1">// no additional parameters (cell/particle indices)</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">CudaCompatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w">                </span><span class="c1">// CUDA compatible</span>
<span class="w">  </span><span class="p">};</span>
<span class="p">}</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">exaStamp</span><span class="w"> </span><span class="p">{</span>
<span class="k">template</span><span class="o">&lt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">GridT</span><span class="w">                                                      </span><span class="c1">// our component adapts to any grid type</span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AssertGridHasFields</span><span class="o">&lt;</span><span class="n">GridT</span><span class="p">,</span><span class="n">field</span><span class="o">::</span><span class="n">_fx</span><span class="p">,</span><span class="n">field</span><span class="o">::</span><span class="n">_fy</span><span class="p">,</span><span class="n">field</span><span class="o">::</span><span class="n">_fz</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="c1">// as long as particles have fx, fy, and fz attributes</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SumForceNorm</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">OperatorNode</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ADD_SLOT</span><span class="p">(</span><span class="n">GridT</span><span class="p">,</span><span class="w"> </span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">INPUT</span><span class="p">,</span><span class="w"> </span><span class="n">REQUIRED</span><span class="p">);</span><span class="w">    </span><span class="c1">// grid containing cells and all particles within the sub-domain</span>
<span class="w">    </span><span class="n">ADD_SLOT</span><span class="p">(</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">sum_norm</span><span class="p">,</span><span class="w"> </span><span class="n">OUTPUT</span><span class="p">);</span><span class="w">       </span><span class="c1">// output value = sum of force norms</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">execute</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">final</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">reduce_fields_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FieldSet</span><span class="o">&lt;</span><span class="n">field</span><span class="o">::</span><span class="n">fx</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">fy</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">fz</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// fields on which our functor operates</span>
<span class="w">    </span><span class="n">ReduceVec3NormFunctor</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span><span class="w">                                    </span><span class="c1">// instantiate the functor for summing force norms</span>
<span class="w">    </span><span class="o">*</span><span class="n">sum_norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">    </span><span class="n">reduce_cell_particles</span><span class="p">(</span><span class="o">*</span><span class="n">grid</span><span class="w">                         </span><span class="c1">// grid containing particles of the system</span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="w">                         </span><span class="c1">// do not compute in ghost zones</span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="n">func</span><span class="w">                          </span><span class="c1">// functor to use</span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">sum_norm</span><span class="w">                     </span><span class="c1">// initial value for reduction input, final result output</span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="n">reduce_fields_t</span><span class="p">{}</span><span class="w">             </span><span class="c1">// fields used for reduction, defines call parameters</span>
<span class="w">                         </span><span class="p">,</span><span class="w"> </span><span class="n">parallel_execution_context</span><span class="p">()</span><span class="w">  </span><span class="c1">// current component&#39;s parallel execution context</span>
<span class="w">                         </span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// component registration similar to the one in the example for compute_cell_particles</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This code defines a component (<code class="docutils literal notranslate"><span class="pre">SumForceNorm</span></code>) that computes the sum of norms of forces acting on particles within a grid (<cite>grid</cite>). Key points to note:</p>
<ul class="simple">
<li><p>It uses a functor (ReduceVec3NormFunctor) with multiple operator overloads to perform reduction across particles in three stages: local to each thread, within each thread block, and globally across all thread blocks.</p></li>
<li><p>Traits (<code class="docutils literal notranslate"><span class="pre">ReduceCellParticlesTraits</span></code>) are specialized to specify that the functor supports <cite>CUDA</cite> and does not require intra-block thread synchronization.</p></li>
<li><p>The component is registered using <code class="docutils literal notranslate"><span class="pre">OperatorNodeFactory</span></code>, making it accessible under a specific name for instantiation.</p></li>
</ul>
<p>This example demonstrates advanced parallel computation techniques within a particle system framework (<cite>exaNBody</cite>), focusing on efficient reduction operations across large datasets.</p>
</section>
<section id="compute-pair-interaction">
<h2><span class="section-number">6.4. </span>Compute Pair Interaction<a class="headerlink" href="#compute-pair-interaction" title="Permalink to this heading"></a></h2>
<p>Pattern Overview:</p>
<ul>
<li><p>Purpose: Compute interactions (potentials or forces) between pairs of particles based on their proximity (rij &lt; rcut).
- Components: Utilizes both particle grids and neighbor lists (see neighbor lists section).
- Two Invocation Modes:</p>
<blockquote>
<div><ul class="simple">
<li><p>With Buffer: Collects attributes of neighboring particles into a buffer before invoking the user-defined functor once with this buffer.</p></li>
<li><p>Without Buffer: Computes interactions “on-the-fly” without pre-collecting neighbors’ attributes.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Usage Examples:
- Scenario 1: Interaction potentials require knowledge of all neighboring particles of at least one of the particles involved. Here, <cite>compute_cell_particle_pairs</cite> first accumulates neighbors’ attributes into a buffer and then invokes the user functor.
- Scenario 2: Interaction potentials only require attributes of the two particles involved, making it efficient to compute interactions without using an intermediate buffer.</p></li>
<li><p>Flexibility:
- Functors can be implemented to support both invocation protocols (with and without buffer), allowing the subsystem to choose the optimal method based on execution environment and computational requirements.
- Functors can choose to implement only one of these protocols if the scenario allows for a straightforward implementation.</p></li>
<li><p>Implementation:
- The pattern involves defining a functor (<code class="docutils literal notranslate"><span class="pre">ComputePairInteractionFunctor</span></code>) that encapsulates the logic for computing interactions between pairs of particles.
- Traits (<code class="docutils literal notranslate"><span class="pre">ComputeCellParticlePairsTraits</span></code>) are used to specify compatibility with <cite>CUDA</cite> and whether synchronous block calls are required.</p></li>
</ul>
<p>Header files:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma xstamp_enable_cuda                           </span><span class="c1">// Enable compilation with nvcc, allowing GPU code generation</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exanb/core/operator.h&gt;</span><span class="c1">                     // Base to create a component</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exanb/core/operator_factory.h&gt;</span><span class="c1">             // For registering the component</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exanb/core/operator_slot.h&gt;</span><span class="c1">                // For declaring component slots</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exanb/core/make_grid_variant_operator.h&gt;</span><span class="c1">   // For registering a template component</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exanb/core/grid.h&gt;</span><span class="c1">                         // Defines the Grid type containing particles</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exanb/core/domain.h&gt;</span><span class="c1">                       // Domain type, represents the simulation domain</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exanb/particle_neighbors/chunk_neighbors.h&gt;</span><span class="c1">// GridChunkNeighbors type ⇒ lists of neighbors</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exanb/compute/compute_cell_particle_pairs.h&gt;</span><span class="c1">// For compute_cell_particle_pairs function</span>
</pre></div>
</div>
<p>Functor Creation:</p>
<p>For this example (lennard jones potential), we implement both possible forms of invocation so that our functor can be used with or without an intermediate buffer. This allows <cite>compute_cell_particle_pairs</cite> to choose the most efficient method based on the context. In practice, you can implement only one of these forms (if your potential formulation allows) or both-either way, it will work on both <cite>CPU</cite> and <cite>GPU</cite>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">microStamp</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">exanb</span><span class="p">;</span>

<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">LennardJonesForceFunctor</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">LennardJonesParms</span><span class="w"> </span><span class="n">m_params</span><span class="p">;</span><span class="w">  </span><span class="c1">// parameters of our interaction potential</span>
<span class="w">    </span><span class="c1">// Operator for using an intermediate buffer containing all neighbors</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">ComputePairBufferT</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">CellParticlesT</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">ONIKA_HOST_DEVICE_FUNC</span>
<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">(</span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w">                                </span><span class="c1">// number of neighboring particles</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">ComputePairBufferT</span><span class="o">&amp;</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w">         </span><span class="c1">// intermediate buffer containing neighbor information</span>
<span class="w">        </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">,</span><span class="w">                                </span><span class="c1">// reference to energy, where we accumulate energy contribution</span>
<span class="w">        </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fx</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fy</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fz</span><span class="p">,</span><span class="w">       </span><span class="c1">// references to force components where we add interaction contribution</span>
<span class="w">        </span><span class="n">CellParticlesT</span><span class="o">*</span><span class="w"> </span><span class="n">cells</span><span class="w">                    </span><span class="c1">// array of all cells, in case additional information is needed</span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">double</span><span class="w"> </span><span class="n">_e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w">                           </span><span class="c1">// local contributions, initialized to 0</span>
<span class="w">      </span><span class="kt">double</span><span class="w"> </span><span class="n">_fx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">      </span><span class="kt">double</span><span class="w"> </span><span class="n">_fy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">      </span><span class="kt">double</span><span class="w"> </span><span class="n">_fz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>

<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">           </span><span class="c1">// loop over neighbors in the buffer</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">d2</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">pair_e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="n">pair_de</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>

<span class="w">        </span><span class="n">lj_compute_energy</span><span class="p">(</span><span class="n">m_params</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">pair_e</span><span class="p">,</span><span class="w"> </span><span class="n">pair_de</span><span class="p">);</span><span class="w">  </span><span class="c1">// calculate energy and its derivative</span>

<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">interaction_weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">nbh_data</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">        </span><span class="n">pair_e</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">interaction_weight</span><span class="p">;</span><span class="w">                    </span><span class="c1">// weight the interaction and normalize over distance rij</span>
<span class="w">        </span><span class="n">pair_de</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">interaction_weight</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>

<span class="w">        </span><span class="n">_fx</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">pair_de</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">drx</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w">                  </span><span class="c1">// add contributions from the i-th neighbor</span>
<span class="w">        </span><span class="n">_fy</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">pair_de</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">dry</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="n">_fz</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">pair_de</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">drz</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="n">_e</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pair_e</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="n">e</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">_e</span><span class="p">;</span><span class="w">   </span><span class="c1">// add local contributions to energy and force fields of the central particle</span>
<span class="w">      </span><span class="n">fx</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">_fx</span><span class="p">;</span>
<span class="w">      </span><span class="n">fy</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">_fy</span><span class="p">;</span>
<span class="w">      </span><span class="n">fz</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">_fz</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Operator for without buffer: one call per neighboring particle</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">CellParticlesT</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">ONIKA_HOST_DEVICE_FUNC</span>
<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">(</span>
<span class="w">        </span><span class="n">Vec3d</span><span class="w"> </span><span class="n">dr</span><span class="p">,</span><span class="w">                           </span><span class="c1">// relative position of the neighboring particle</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">d2</span><span class="p">,</span><span class="w">                          </span><span class="c1">// square of the distance to the neighboring particle</span>
<span class="w">        </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fx</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fy</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fz</span><span class="p">,</span><span class="w">  </span><span class="c1">// references to variables to update with energy and force contributions of the pair</span>
<span class="w">        </span><span class="n">CellParticlesT</span><span class="o">*</span><span class="w"> </span><span class="n">cells</span><span class="p">,</span><span class="w">              </span><span class="c1">// array of all cells, in case additional information is needed</span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">neighbor_cell</span><span class="p">,</span><span class="w">               </span><span class="c1">// index of the cell where the neighboring particle resides</span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">neighbor_particle</span><span class="p">,</span><span class="w">           </span><span class="c1">// index of the neighboring particle within its cell</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">interaction_weight</span><span class="w">           </span><span class="c1">// weighting to apply on the interaction</span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">d2</span><span class="p">);</span>
<span class="w">      </span><span class="kt">double</span><span class="w"> </span><span class="n">pair_e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="n">pair_de</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>

<span class="w">      </span><span class="n">lj_compute_energy</span><span class="p">(</span><span class="n">m_params</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">pair_e</span><span class="p">,</span><span class="w"> </span><span class="n">pair_de</span><span class="p">);</span><span class="w">  </span><span class="c1">// calculate energy and its derivative</span>
<span class="w">      </span><span class="n">pair_e</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">interaction_weight</span><span class="p">;</span><span class="w">                    </span><span class="c1">// weight and normalize by distance</span>
<span class="w">      </span><span class="n">pair_de</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">interaction_weight</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>

<span class="w">      </span><span class="n">fx</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">pair_de</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dr</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w">                            </span><span class="c1">// add contributions of the pair to energy and forces of the central particle</span>
<span class="w">      </span><span class="n">fy</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">pair_de</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dr</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="w">      </span><span class="n">fz</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">pair_de</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dr</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="w">      </span><span class="n">e</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pair_e</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Define the compile-time characteristics of the functor:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">exanb</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">ComputePairTraits</span><span class="o">&lt;</span><span class="w"> </span><span class="n">microStamp</span><span class="o">::</span><span class="n">LennardJonesForceFunctor</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="c1">// specialization for our functor</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">RequiresBlockSynchronousCall</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// no collaboration between threads within a block</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">ComputeBufferCompatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w">  </span><span class="c1">// allows invocation with a compute buffer</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">BufferLessCompatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w">     </span><span class="c1">// allows invocation without a buffer, for each neighbor</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">CudaCompatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w">           </span><span class="c1">// compatible with Cuda</span>
<span class="w">  </span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Performing the calculation in parallel within the execute method of our component:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">GridT</span><span class="p">,</span><span class="w">                                                            </span><span class="c1">// our component adapts to any type of grid</span>
<span class="w">  </span><span class="k">class</span><span class="o">=</span><span class="n">AssertGridHasFields</span><span class="o">&lt;</span><span class="n">GridT</span><span class="p">,</span><span class="n">field</span><span class="o">::</span><span class="n">_ep</span><span class="p">,</span><span class="n">field</span><span class="o">::</span><span class="n">_fx</span><span class="p">,</span><span class="n">field</span><span class="o">::</span><span class="n">_fy</span><span class="p">,</span><span class="n">field</span><span class="o">::</span><span class="n">_fz</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="c1">// which particles have attributes ep, fx, fy, and fz</span>
<span class="k">class</span><span class="w"> </span><span class="nc">LennardJonesForce</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">OperatorNode</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ADD_SLOT</span><span class="p">(</span><span class="w"> </span><span class="n">LennardJonesParms</span><span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">config</span><span class="w">         </span><span class="p">,</span><span class="w"> </span><span class="n">INPUT</span><span class="p">,</span><span class="w"> </span><span class="n">REQUIRED</span><span class="p">);</span><span class="w">  </span><span class="c1">// parameters of our potential</span>
<span class="w">  </span><span class="n">ADD_SLOT</span><span class="p">(</span><span class="w"> </span><span class="kt">double</span><span class="w">                   </span><span class="p">,</span><span class="w"> </span><span class="n">rcut</span><span class="w">           </span><span class="p">,</span><span class="w"> </span><span class="n">INPUT</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span><span class="w">       </span><span class="c1">// cutoff radius</span>
<span class="w">  </span><span class="n">ADD_SLOT</span><span class="p">(</span><span class="w"> </span><span class="n">exanb</span><span class="o">::</span><span class="n">GridChunkNeighbors</span><span class="p">,</span><span class="w"> </span><span class="n">chunk_neighbors</span><span class="p">,</span><span class="w"> </span><span class="n">INPUT</span><span class="p">,</span><span class="w"> </span><span class="n">exanb</span><span class="o">::</span><span class="n">GridChunkNeighbors</span><span class="p">{});</span><span class="w"> </span><span class="c1">// neighbor lists</span>
<span class="w">  </span><span class="n">ADD_SLOT</span><span class="p">(</span><span class="w"> </span><span class="kt">bool</span><span class="w">                     </span><span class="p">,</span><span class="w"> </span><span class="n">ghost</span><span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">INPUT</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span><span class="w">            </span><span class="c1">// indicates if we calculate in ghost zones</span>
<span class="w">  </span><span class="n">ADD_SLOT</span><span class="p">(</span><span class="w"> </span><span class="n">Domain</span><span class="w">                   </span><span class="p">,</span><span class="w"> </span><span class="n">domain</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">INPUT</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">REQUIRED</span><span class="p">);</span><span class="w">         </span><span class="c1">// simulation domain</span>
<span class="w">  </span><span class="n">ADD_SLOT</span><span class="p">(</span><span class="w"> </span><span class="n">GridT</span><span class="w">                    </span><span class="p">,</span><span class="w"> </span><span class="n">grid</span><span class="w">   </span><span class="p">,</span><span class="w"> </span><span class="n">INPUT_OUTPUT</span><span class="w"> </span><span class="p">);</span><span class="w">            </span><span class="c1">// grid containing particles in the local subdomain</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">ComputeBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ComputePairBuffer2</span><span class="o">&lt;&gt;</span><span class="p">;</span><span class="w">                              </span><span class="c1">// shortcut for the type &quot;buffer containing neighbors&quot;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">CellParticles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">GridT</span><span class="o">::</span><span class="n">CellParticles</span><span class="p">;</span><span class="w">                     </span><span class="c1">// shortcut for the type &quot;grid cell&quot;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">NeighborIterator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">exanb</span><span class="o">::</span><span class="n">GridChunkNeighborsLightWeightIt</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;</span><span class="p">;</span><span class="w">  </span><span class="c1">// shortcut for the type &quot;neighbor iterator&quot;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">ComputeFields</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FieldSet</span><span class="o">&lt;</span><span class="n">field</span><span class="o">::</span><span class="n">_ep</span><span class="w">    </span><span class="c1">// type defining the list of fields on which our functor operates</span>
<span class="w">                                </span><span class="p">,</span><span class="n">field</span><span class="o">::</span><span class="n">_fx</span><span class="w">    </span><span class="c1">// this list determines part of the functor&#39;s call parameters</span>
<span class="w">                                </span><span class="p">,</span><span class="n">field</span><span class="o">::</span><span class="n">_fy</span><span class="w">    </span><span class="c1">// we declare ep, fx, fy, and fz, which are of type double, so we will find</span>
<span class="w">                                </span><span class="p">,</span><span class="n">field</span><span class="o">::</span><span class="n">_fz</span><span class="o">&gt;</span><span class="p">;</span><span class="w">  </span><span class="c1">// references to these attributes as parameters of our functor.</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">execute</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">final</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">optional</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_compute_pair_optional_args</span><span class="p">(</span><span class="w">        </span><span class="c1">// builds the list of particle traversal options</span>
<span class="w">                      </span><span class="n">NeighborIterator</span><span class="p">{</span><span class="w"> </span><span class="o">*</span><span class="n">chunk_neighbors</span><span class="w"> </span><span class="p">}</span><span class="w">  </span><span class="c1">// iterator over neighbor lists</span>
<span class="w">                    </span><span class="p">,</span><span class="w"> </span><span class="n">ComputePairNullWeightIterator</span><span class="p">{}</span><span class="w">       </span><span class="c1">// iterator over weighting values (no weighting here)</span>
<span class="w">                    </span><span class="p">,</span><span class="w"> </span><span class="n">LinearXForm</span><span class="p">{</span><span class="w"> </span><span class="n">domain</span><span class="o">-&gt;</span><span class="n">xform</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w">        </span><span class="c1">// transformation to apply on particle positions (domain deformation here)</span>
<span class="w">                    </span><span class="p">,</span><span class="w"> </span><span class="n">ComputePairOptionalLocks</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;</span><span class="p">{});</span><span class="w">   </span><span class="c1">// accessor to particle access locks (no locking here)</span>
<span class="w">    </span><span class="n">compute_cell_particle_pairs</span><span class="p">(</span><span class="w"> </span><span class="o">*</span><span class="n">grid</span><span class="w">                                     </span><span class="c1">// grid containing particles</span>
<span class="w">                               </span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">rcut</span><span class="w">                                     </span><span class="c1">// cutoff radius</span>
<span class="w">                               </span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">ghost</span><span class="w">                                    </span><span class="c1">// whether to calculate in ghost zones or not</span>
<span class="w">                               </span><span class="p">,</span><span class="w"> </span><span class="n">optional</span><span class="w">                                  </span><span class="c1">// particle traversal options</span>
<span class="w">                               </span><span class="p">,</span><span class="w"> </span><span class="n">make_compute_pair_buffer</span><span class="o">&lt;</span><span class="n">ComputeBuffer</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="c1">// creates neighbor buffers</span>
<span class="w">                               </span><span class="p">,</span><span class="w"> </span><span class="n">LennardJonesForceFunctor</span><span class="p">{</span><span class="w"> </span><span class="o">*</span><span class="n">config</span><span class="w"> </span><span class="p">}</span><span class="w">       </span><span class="c1">// instantiation of our functor with user parameters</span>
<span class="w">                               </span><span class="p">,</span><span class="w"> </span><span class="n">ComputeFields</span><span class="p">{}</span><span class="w">                           </span><span class="c1">// attributes on which our functor operates</span>
<span class="w">                               </span><span class="p">,</span><span class="w"> </span><span class="n">DefaultPositionFields</span><span class="p">{}</span><span class="w">                   </span><span class="c1">// uses default attributes (rx, ry, and rz) for particle positions</span>
<span class="w">                               </span><span class="p">,</span><span class="w"> </span><span class="n">parallel_execution_context</span><span class="p">()</span><span class="w"> </span><span class="p">);</span><span class="w">           </span><span class="c1">// parallel execution context of the current component</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
</section>
<section id="list-of-plugins">
<h1><span class="section-number">7. </span>List of Plugins<a class="headerlink" href="#list-of-plugins" title="Permalink to this heading"></a></h1>
<section id="defbox">
<h2><span class="section-number">7.1. </span>DefBox<a class="headerlink" href="#defbox" title="Permalink to this heading"></a></h2>
<section id="operator-a">
<h3><span class="section-number">7.1.1. </span>Operator a<a class="headerlink" href="#operator-a" title="Permalink to this heading"></a></h3>
</section>
<section id="operator-b">
<h3><span class="section-number">7.1.2. </span>Operator b<a class="headerlink" href="#operator-b" title="Permalink to this heading"></a></h3>
</section>
<section id="operator-c">
<h3><span class="section-number">7.1.3. </span>Operator c<a class="headerlink" href="#operator-c" title="Permalink to this heading"></a></h3>
</section>
</section>
<section id="core-features">
<h2><span class="section-number">7.2. </span>Core features<a class="headerlink" href="#core-features" title="Permalink to this heading"></a></h2>
<p>Independently from any loaded plugins, a set of core feature are always available for use.
This includes, but is not limited to, domain description, particle grid, mpi core features, and more.</p>
<section id="domain">
<h3><span class="section-number">7.2.1. </span>Domain<a class="headerlink" href="#domain" title="Permalink to this heading"></a></h3>
<p>The domain struct holds information about simulation domain size and properties. It is initialized by an operator named “domain” in the YAML input file.
Main domain properties are :</p>
<ul class="simple">
<li><p>domain lower and upper bounds</p></li>
<li><p>cell size</p></li>
<li><p>cell grid dimensions</p></li>
<li><p>boundary condtions</p></li>
</ul>
<p>Here after is an exemple of domain initialization using the “domain” operator :</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">domain</span><span class="p">:</span>
<span class="w">  </span><span class="nt">cell_size</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">10.0 ang</span>
<span class="w">  </span><span class="nt">bounds</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="w"> </span><span class="nv">0.0</span><span class="w"> </span><span class="p p-Indicator">,</span><span class="w"> </span><span class="nv">0.0</span><span class="w"> </span><span class="p p-Indicator">,</span><span class="w"> </span><span class="nv">0.0</span><span class="w"> </span><span class="p p-Indicator">]</span><span class="w"> </span><span class="p p-Indicator">,</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="w"> </span><span class="nv">10.0</span><span class="w"> </span><span class="p p-Indicator">,</span><span class="w"> </span><span class="nv">10.0</span><span class="w"> </span><span class="p p-Indicator">,</span><span class="w"> </span><span class="nv">10.0</span><span class="w"> </span><span class="p p-Indicator">]</span><span class="w"> </span><span class="p p-Indicator">]</span>
<span class="w">  </span><span class="nt">periodic</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">false</span><span class="p p-Indicator">,</span><span class="nv">true</span><span class="p p-Indicator">,</span><span class="nv">true</span><span class="p p-Indicator">]</span>
<span class="w">  </span><span class="nt">mirror</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="w"> </span><span class="nv">X-</span><span class="w"> </span><span class="p p-Indicator">]</span>
</pre></div>
</div>
<p>Periodic indicates which directions have periodic boundary conditions. Mirror tells wich sides have mirror (reflective) boundary conditions.
A reflective mirror side can be applied on any side of the domain box. A direction with at leat one mirror boundary cannot be periodic, and vice-versa.
As an exemple, if X direction is not periodic, it can have mirror condition and the lower end (X-) and/or the upper end (X+). If user set X to be periodic and add a X-/X+
mirror, X periodicity is disabled automatically. Finally, mirror property is a list of sides on which mirror conditions are applied, among X-, X+, X, Y-, Y+, Y, Z-, Z+ and Z.
mirror sides X is a shortcut for enabling X- and X+ at the same time, so is Y and Z.</p>
</section>
</section>
<section id="logic">
<h2><span class="section-number">7.3. </span>Logic<a class="headerlink" href="#logic" title="Permalink to this heading"></a></h2>
</section>
<section id="amr">
<h2><span class="section-number">7.4. </span>AMR<a class="headerlink" href="#amr" title="Permalink to this heading"></a></h2>
</section>
<section id="particleneighbors">
<h2><span class="section-number">7.5. </span>ParticleNeighbors<a class="headerlink" href="#particleneighbors" title="Permalink to this heading"></a></h2>
</section>
<section id="gridcellparticles">
<h2><span class="section-number">7.6. </span>GridCellParticles<a class="headerlink" href="#gridcellparticles" title="Permalink to this heading"></a></h2>
<section id="cartesian-field-grid">
<h3><span class="section-number">7.6.1. </span>Cartesian Field Grid<a class="headerlink" href="#cartesian-field-grid" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>Operator Name: <code class="docutils literal notranslate"><span class="pre">set_cell_values</span></code></p></li>
<li><p>Description: This operator initializes values of a specific cell value field, and creates it if needed. optionally, initialization can be bounded to a specified region, the rest of field beeing set to all 0. This operator can also be used to refine the grid.</p></li>
<li><p>Parameters:</p>
<ul>
<li><p>region: Region of the field where the value is to be applied.</p></li>
<li><p>grid_subdiv: Number of (uniform) subdivisions required for this field. Note that the refinement is an octree.</p></li>
<li><p>field_name: Name of the field.</p></li>
<li><p>value: List of the values affected to the field.</p></li>
</ul>
</li>
</ul>
<p>YAML example:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">set_cell_values</span><span class="p">:</span>
<span class="w">   </span><span class="nt">field_name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">jet</span>
<span class="w">   </span><span class="nt">grid_subdiv</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">30</span>
<span class="w">   </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">1</span><span class="p p-Indicator">,</span><span class="w"> </span><span class="nv">0</span><span class="p p-Indicator">,</span><span class="w"> </span><span class="nv">0</span><span class="p p-Indicator">,</span><span class="w"> </span><span class="nv">20</span><span class="p p-Indicator">]</span>
<span class="w">   </span><span class="nt">region</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">GEYSERE</span>
</pre></div>
</div>
</section>
</section>
<section id="io">
<h2><span class="section-number">7.7. </span>IO<a class="headerlink" href="#io" title="Permalink to this heading"></a></h2>
</section>
<section id="extra-storage">
<h2><span class="section-number">7.8. </span>Extra Storage<a class="headerlink" href="#extra-storage" title="Permalink to this heading"></a></h2>
<p>The purpose of this plugin is to add dynamic storage of any type associated with a particle. This package provides the data structure for storage, the associated MPI buffers and operators to move data between grid cells (move particle and migrate cell particles). This package was designed to meet the needs of exaDEM, as friction force values must be preserved from one time step to another. Additionally, this package allows for additional storage in the dump.</p>
<p>To utilize this additional storage, you need to use the data structure <em>ExtraDynamicDataStorageCellMoveBufferT</em> with your data type and the slot name <em>ges</em> for <em>grid extra storage</em>. This structure is a grid of <em>CellExtraDynamicDataStorageT</em>, which itself contains an array of your data type (m_data) and a particle information array (m_info) containing the start index in the m_data array, the number of stored data, and the particle index.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ItemType</span><span class="o">&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">CellExtraDynamicDataStorageT</span>
<span class="k">using</span><span class="w"> </span><span class="n">UIntType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint64_t</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">InfoType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExtraStorageInfo</span><span class="p">;</span>
<span class="n">onika</span><span class="o">::</span><span class="n">memory</span><span class="o">::</span><span class="n">CudaMMVector</span><span class="o">&lt;</span><span class="n">InfoType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_info</span><span class="p">;</span><span class="w"> </span><span class="cm">/**&lt; Info vector storing indices of the [start, number of items, particle id] of each cell&#39;s extra dynamic data in m_data. */</span>
<span class="n">onika</span><span class="o">::</span><span class="n">memory</span><span class="o">::</span><span class="n">CudaMMVector</span><span class="o">&lt;</span><span class="n">ItemType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_data</span><span class="p">;</span><span class="w"> </span><span class="cm">/**&lt; Data vector storing the extra dynamic data for each cell. */</span>
</pre></div>
</div>
<p>The filling of these data structures is your responsibility; however, it is possible to instantiate an operator to verify that the filling has been done correctly:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">exanb</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">GridT</span><span class="o">&gt;</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">CheckInfoConsistencyYourDataTypeTmpl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CheckInfoConsistency</span><span class="o">&lt;</span><span class="n">GridT</span><span class="p">,</span><span class="w"> </span><span class="n">GridExtraDynamicDataStorageT</span><span class="o">&lt;</span><span class="n">YOUR_DATA_TYPE</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// === register factories ===</span>
<span class="w">  </span><span class="n">CONSTRUCTOR_FUNCTION</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">OperatorNodeFactory</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">register_factory</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;check_es_consistency_your_data_type&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">make_grid_variant_operator</span><span class="o">&lt;</span><span class="w"> </span><span class="n">CheckInfoConsistencyYourDataTypeTmpl</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The following code is an example of how to correctly fill the data structure (type = Interaction):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="n">GridExtraDynamicDataStorageT</span><span class="o">&lt;</span><span class="n">Interaction</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GridCellParticleInteraction</span><span class="p">;</span>
<span class="n">ADD_SLOT</span><span class="p">(</span><span class="w"> </span><span class="n">GridT</span><span class="p">,</span><span class="w"> </span><span class="n">grid</span><span class="p">,</span><span class="w"> </span><span class="n">INPUT_OUTPUT</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">REQUIRED</span><span class="w"> </span><span class="p">);</span>
<span class="n">ADD_SLOT</span><span class="p">(</span><span class="w"> </span><span class="n">GridCellParticleInteraction</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">ges</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">INPUT_OUTPUT</span><span class="w"> </span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">grid</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">cells</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">cells</span><span class="p">();</span>
<span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n_cells</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">number_of_cells</span><span class="p">();</span><span class="w"> </span><span class="c1">// nbh.size();</span>
<span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ces</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ges</span><span class="o">-&gt;</span><span class="n">m_data</span><span class="p">;</span>
<span class="n">assert</span><span class="p">(</span><span class="w"> </span><span class="n">ces</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n_cells</span><span class="w"> </span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="n">IJK</span><span class="w"> </span><span class="n">dims</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">dimension</span><span class="p">();</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">gl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">ghost_layers</span><span class="p">();</span>

<span class="cp">#pragma omp parallel</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Interaction</span><span class="w"> </span><span class="n">item</span><span class="p">;</span>
<span class="w">  </span><span class="n">GRID_OMP_FOR_BEGIN</span><span class="p">(</span><span class="n">dims</span><span class="mi">-2</span><span class="o">*</span><span class="n">gl</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">block_loc</span><span class="p">,</span><span class="w"> </span><span class="n">schedule</span><span class="p">(</span><span class="n">guided</span><span class="p">)</span><span class="w"> </span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">IJK</span><span class="w"> </span><span class="n">loc_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block_loc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">gl</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cell_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">grid_ijk_to_index</span><span class="p">(</span><span class="w"> </span><span class="n">dims</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">loc_a</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n_particles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cells</span><span class="p">[</span><span class="n">cell_a</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
<span class="w">    </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">storage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ces</span><span class="p">[</span><span class="n">cell_a</span><span class="p">];</span>
<span class="w">    </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">storage</span><span class="p">.</span><span class="n">m_data</span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">storage</span><span class="p">.</span><span class="n">m_info</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// auto&amp; history = extract_history(data);</span>
<span class="w">    </span><span class="c1">// You can extract data before initialize.</span>
<span class="w">    </span><span class="n">storage</span><span class="p">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">n_particles</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n_particles</span><span class="w"> </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Do some stuff and fill item.</span>
<span class="w">      </span><span class="c1">// You can add several items here.</span>
<span class="w">      </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">      </span><span class="n">size</span><span class="o">++</span>
<span class="w">      </span><span class="n">m_data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
<span class="w">                        </span><span class="c1">// you can update the particle offset here.</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">GRID_OMP_FOR_END</span>
<span class="w">  </span><span class="c1">// you can fit offsets here instead of in the omp loop. (offset(i) = offset(i-1) + size(i-1))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Warning:</p>
<blockquote>
<div><ul class="simple">
<li><p>This package allows for as many external storages as there are types; however, it’s not possible to have two additional storages of the same type.</p></li>
<li><p>Don’t forget to adjust the size of this storage to the number of cells in the grid when first using it.</p></li>
<li><p>This package does not integrate with routines for particle-level calculations such as <cite>compute_cell_particles</cite>.</p></li>
</ul>
</div></blockquote>
<p>Tip:</p>
<blockquote>
<div><ul class="simple">
<li><p>Before sending or writing data, consider removing unnecessary information. For example, in DEM, if the friction is equal to (0,0,0), you can overwrite this data to save space. (more details, see in exaDEM <cite>compress_interaction</cite> operator).</p></li>
</ul>
</div></blockquote>
<section id="extra-data-checker">
<h3><span class="section-number">7.8.1. </span>Extra Data Checker<a class="headerlink" href="#extra-data-checker" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>Operator: <cite>check_es_consistency_double</cite></p>
<ul>
<li><p><cite>Description</cite> : This opertor checks if for each particle information the offset and size are correct</p></li>
<li><p><cite>ges</cite> : Your grid of addictionnal data storage.</p></li>
</ul>
</li>
</ul>
<p>YAML example:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">check_es_consistency_double</span>
</pre></div>
</div>
</section>
<section id="migrate-cell-particles-with-extra-storage">
<h3><span class="section-number">7.8.2. </span>Migrate Cell Particles With Extra Storage<a class="headerlink" href="#migrate-cell-particles-with-extra-storage" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>Operator: <cite>migrate_cell_particles_double</cite> (example)</p>
<ul>
<li><p><cite>Description</cite> : migrate_cell_particles does 2 things:</p>
<ul>
<li><ol class="arabic simple">
<li><p>it repartitions the data accross mpi processes, as described by lb_block.</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="2">
<li><p>it reserves space for ghost particles, but do not populate ghost cells with particles. The ghost layer thickness (in number of cells) depends on ghost_dist. Inputs from different mpi process may have overlapping cells (but no duplicate particles). the result grids (of every mpi processes) never have overlapping cells. The ghost cells are always empty after this operator.</p></li>
</ol>
</li>
</ul>
</li>
<li><p><cite>ges</cite> : Your grid of addictionnal data storage.</p></li>
<li><p><cite>bes</cite> : Your buffer used for particles moving outside the box</p></li>
<li><p><cite>buffer_size</cite> : Performance tuning parameter. Size of send/receive buffers in number of particles.</p></li>
<li><p><cite>copy_task_threshold</cite> :  Performance tuning parameter. Number of particles in a cell above which an asynchronous OpenMP task is created to pack particles to send buffer.</p></li>
<li><p><cite>extra_receive_buffers</cite>: Performance tuning parameter. Number of extraneous receive buffers allocated allowing for asynchronous (OpenMP task) particle unpacking. A negative value n is interpereted as -n*NbMpiProcs</p></li>
<li><p><cite>force_lb_change</cite> : Force particle packing/unpacking to and from send buffers even if a load balancing has not been triggered</p></li>
<li><p><cite>otb_particles</cite> : Particles outside of local processor’s grid</p></li>
</ul>
</li>
<li><p>In practice, do not tune this operator yourself.</p></li>
</ul>
<p>How to create your operator:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exanb/extra_storage/migrate_cell_particles_es.hpp&gt;</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">exanb</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">GridT</span><span class="o">&gt;</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">MigrateCellParticlesYourDataTypeTmpl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MigrateCellParticlesES</span><span class="o">&lt;</span><span class="n">GridT</span><span class="p">,</span><span class="w"> </span><span class="n">GridExtraDynamicDataStorageT</span><span class="o">&lt;</span><span class="n">your_data_type</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// === register factory ===</span>
<span class="w">  </span><span class="n">CONSTRUCTOR_FUNCTION</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">OperatorNodeFactory</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">register_factory</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;migrate_cell_particles_your_data_type&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">make_grid_variant_operator</span><span class="o">&lt;</span><span class="n">MigrateCellParticlesYourDataTypeTmpl</span><span class="o">&gt;</span><span class="w"> </span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>YAML example:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">migrate_cell_particles_double</span>
</pre></div>
</div>
</section>
<section id="move-particles-with-extra-storage">
<h3><span class="section-number">7.8.3. </span>Move Particles With Extra Storage<a class="headerlink" href="#move-particles-with-extra-storage" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>Operator: <cite>migrate_cell_particles_double</cite> (example)</p>
<ul>
<li><p><cite>Description</cite> : This operator moves particles and extra data storage (es) across cells.</p></li>
<li><p><cite>ges</cite> : Your grid of addictionnal data storage.</p></li>
<li><p><cite>bes</cite> : Your buffer used for particles moving outside the box</p></li>
<li><p><cite>otb_particles</cite> ; Particles outside of local processor’s grid</p></li>
<li><p>In practice, do not tune this operator yourself</p></li>
</ul>
</li>
</ul>
<p>How to create your operator:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exanb/extra_storage/move_particles_es.hpp&gt;</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">exanb</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">GridT</span><span class="o">&gt;</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">MoveParticlesYourDataTypeTmpl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MigrateCellParticlesWithES</span><span class="o">&lt;</span><span class="n">GridT</span><span class="p">,</span><span class="w"> </span><span class="n">GridExtraDynamicDataStorageT</span><span class="o">&lt;</span><span class="n">your_data_type</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// === register factory ===</span>
<span class="w">  </span><span class="n">CONSTRUCTOR_FUNCTION</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">OperatorNodeFactory</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">register_factory</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;migrate_cell_particles_your_data_type&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">make_grid_variant_operator</span><span class="o">&lt;</span><span class="n">MoveParticlesYourDataTypeTmpl</span><span class="o">&gt;</span><span class="w"> </span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>YAML example:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">move_particles_double</span>
</pre></div>
</div>
</section>
<section id="io-writer-with-extra-data">
<h3><span class="section-number">7.8.4. </span>IO Writer With Extra Data<a class="headerlink" href="#io-writer-with-extra-data" title="Permalink to this heading"></a></h3>
<p>There is no operator in exaNBody for writing dump files with storage because you need to explicitly specify the fields to store. However, we propose a non-instantiated templated operator for this purpose. We provide an example with exaDEM and Interaction data type.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exaDEM/interaction/grid_cell_interaction.hpp&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exanb/extra_storage/sim_dump_writer_es.hpp&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exanb/extra_storage/dump_filter_dynamic_data_storage.h&gt;</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">exaDEM</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">exanb</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">DumpFieldSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FieldSet</span><span class="o">&lt;</span><span class="n">field</span><span class="o">::</span><span class="n">_rx</span><span class="p">,</span><span class="n">field</span><span class="o">::</span><span class="n">_ry</span><span class="p">,</span><span class="n">field</span><span class="o">::</span><span class="n">_rz</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">_vx</span><span class="p">,</span><span class="n">field</span><span class="o">::</span><span class="n">_vy</span><span class="p">,</span><span class="n">field</span><span class="o">::</span><span class="n">_vz</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">_mass</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">_homothety</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">_radius</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">_orient</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">_mom</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">_vrot</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">_arot</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">_inertia</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">_id</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">_shape</span><span class="w"> </span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">GridT</span><span class="o">&gt;</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">SimDumpWriteParticleInteractionTmpl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SimDumpWriteParticleES</span><span class="o">&lt;</span><span class="n">GridT</span><span class="p">,</span><span class="w"> </span><span class="n">exaDEM</span><span class="o">::</span><span class="n">Interaction</span><span class="p">,</span><span class="w"> </span><span class="n">DumpFieldSet</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// === register factories ===</span>
<span class="w">  </span><span class="n">CONSTRUCTOR_FUNCTION</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">OperatorNodeFactory</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">register_factory</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;write_dump_particle_interaction&quot;</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">make_grid_variant_operator</span><span class="o">&lt;</span><span class="n">SimDumpWriteParticleInteractionTmpl</span><span class="o">&gt;</span><span class="w"> </span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For the description of operator slots, see <cite>write_dump_particle_interaction</cite> in exaDEM documentation. Tip: compress extra storage before write dump data file.</p>
<p>YAML example:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">dump_data_particles</span><span class="p">:</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">timestep_file</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;exaDEM_%09d.dump&quot;</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">message</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> mesg</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Write</span><span class="nv"> </span><span class="s">dump</span><span class="nv"> </span><span class="s">&quot;</span><span class="w"> </span><span class="p p-Indicator">,</span><span class="nt"> endl</span><span class="p">:</span><span class="w"> </span><span class="nv">false</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">print_dump_file</span><span class="p">:</span>
<span class="w">      </span><span class="nt">rebind</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> mesg</span><span class="p">:</span><span class="w"> </span><span class="nv">filename</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">      </span><span class="nt">body</span><span class="p">:</span>
<span class="w">        </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">message</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> endl</span><span class="p">:</span><span class="w"> </span><span class="nv">true</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">compress_interaction</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">stats_interactions</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">write_dump_particle_interaction</span>
<span class="w">  </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">chunk_neighbors_impl</span>
</pre></div>
</div>
</section>
<section id="io-reader-with-extra-data">
<h3><span class="section-number">7.8.5. </span>IO Reader With Extra Data<a class="headerlink" href="#io-reader-with-extra-data" title="Permalink to this heading"></a></h3>
<p>There is no operator in exaNBody for reading dump files with storage because you need to explicitly specify the fields to store. However, we propose a non-instantiated templated operator for this purpose. We provide an example with exaDEM and Interaction data type.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exaDEM/interaction/grid_cell_interaction.hpp&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exanb/extra_storage/sim_dump_reader_es.hpp&gt;</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">exaDEM</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">exanb</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">DumpFieldSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FieldSet</span><span class="o">&lt;</span><span class="n">field</span><span class="o">::</span><span class="n">_rx</span><span class="p">,</span><span class="n">field</span><span class="o">::</span><span class="n">_ry</span><span class="p">,</span><span class="n">field</span><span class="o">::</span><span class="n">_rz</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">_vx</span><span class="p">,</span><span class="n">field</span><span class="o">::</span><span class="n">_vy</span><span class="p">,</span><span class="n">field</span><span class="o">::</span><span class="n">_vz</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">_mass</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">_homothety</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">_radius</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">_orient</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">_mom</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">_vrot</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">_arot</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">_inertia</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">_id</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">_shape</span><span class="w"> </span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">GridT</span><span class="o">&gt;</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">SimDumpReadParticleInteractionTmpl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SimDumpReadParticleES</span><span class="o">&lt;</span><span class="n">GridT</span><span class="p">,</span><span class="w"> </span><span class="n">exaDEM</span><span class="o">::</span><span class="n">Interaction</span><span class="p">,</span><span class="w"> </span><span class="n">DumpFieldSet</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// === register factories ===</span>
<span class="w">  </span><span class="n">CONSTRUCTOR_FUNCTION</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">OperatorNodeFactory</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">register_factory</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;read_dump_particle_interaction&quot;</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">make_grid_variant_operator</span><span class="o">&lt;</span><span class="n">SimDumpReadParticleInteractionTmpl</span><span class="o">&gt;</span><span class="w"> </span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For the description of operator slots, see <cite>read_dump_paricle_interaction</cite> in exaDEM documentation.</p>
<p>YAML example:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">read_dump_particle_interaction</span><span class="p">:</span>
<span class="w">   </span><span class="nt">filename</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">last.dump</span>
<span class="w">   </span><span class="nt">override_domain_bounds</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">false</span>
<span class="w">   </span><span class="c1">#scale_cell_size: 0.5</span>
</pre></div>
</div>
</section>
</section>
<section id="mpi">
<h2><span class="section-number">7.9. </span>MPI<a class="headerlink" href="#mpi" title="Permalink to this heading"></a></h2>
<section id="update-ghost-layers">
<h3><span class="section-number">7.9.1. </span>Update Ghost Layers<a class="headerlink" href="#update-ghost-layers" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><dl class="simple">
<dt>Operator: <cite>ghost_update_r</cite> and <cite>ghost_update_all</cite></dt><dd><ul>
<li><p><cite>Description</cite> : These operators are in charge of updating ghost zones between two sub-domains and copying the information required at sub-domains boundaries and for periodic conditions. The <cite>ghost_update_r</cite> operator copies the position while <cite>ghost_update_all</cite> copies all fields defined in your grid type.</p></li>
<li><p><cite>gpu_buffer_pack</cite> : boolean value [false] to decide if you want to port pack/unpack routines on GPU.</p></li>
<li><p><cite>async_buffer_pack</cite> : boolean value [false] triggering to overlap several calls to pack and unpack (send buffers as soon as possibles).</p></li>
<li><p><cite>staging_buffer</cite> :  boolean value [false] triggering the copy to a pure CPU buffer before MPI calls (highly recommended if packaging on GPU)</p></li>
<li><p><cite>serialize_pack_send</cite> : boolean value [false] triggering to wait that all send buffers are built up before sending the first one.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>Example in your msp file:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">ghost_update_r</span><span class="p">:</span>
<span class="w">   </span><span class="nt">gpu_buffer_pack</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span>
<span class="w">   </span><span class="nt">async_buffer_pack</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span>
<span class="w">   </span><span class="nt">staging_buffer</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span>
</pre></div>
</div>
<p>Note that you can customize a <cite>ghost_update_XXX</cite> operator for your application such as :</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">exaDEM</span>
<span class="p">{</span>
<span class="w">        </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">exanb</span><span class="p">;</span>
<span class="w">        </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">UpdateGhostsUtils</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// === register factory ===</span>
<span class="w">        </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">GridT</span><span class="o">&gt;</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">UpdateGhostsYourFields</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UpdateGhostsNode</span><span class="o">&lt;</span><span class="w"> </span><span class="n">GridT</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">FieldSet</span><span class="o">&lt;</span><span class="n">field</span><span class="o">::</span><span class="n">_rx</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">_ry</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="o">::</span><span class="n">_rz</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">list_of_your_fields</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">        </span><span class="n">CONSTRUCTOR_FUNCTION</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">                </span><span class="n">OperatorNodeFactory</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">register_factory</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;ghost_update_XXX&quot;</span><span class="p">,</span><span class="w">     </span><span class="n">make_grid_variant_operator</span><span class="o">&lt;</span><span class="n">UpdateGhostsYourFields</span><span class="o">&gt;</span><span class="w"> </span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="mpi-barrier">
<h3><span class="section-number">7.9.2. </span>MPI Barrier<a class="headerlink" href="#mpi-barrier" title="Permalink to this heading"></a></h3>
<p>This operator is used to create synchronization points between MPI processes. In practice, it is utilized to obtain accurate timing information from operators during performance studies. Otherwise, timing accumulate in operators containing MPI collective routines such as <cite>displ_over</cite>.</p>
<ul class="simple">
<li><p>Operator : <cite>mpi_barrier</cite></p>
<ul>
<li><p><cite>Description</cite> : Add a MPI_Barrier(MPI_COMM_WORLD).</p></li>
<li><p><cite>mpi</cite> : MPI_Comm, default is MPI_COMM_WORLD</p></li>
</ul>
</li>
</ul>
<p>YAML Example:</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">mpi_barrier</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="exanbody-command-lines">
<h1><span class="section-number">8. </span>ExaNBody Command Lines<a class="headerlink" href="#exanbody-command-lines" title="Permalink to this heading"></a></h1>
<p>ExaNBody offers a range of command-line options to facilitate debugging, profiling, and configuring OpenMP settings, providing users with enhanced control and flexibility over the behavior and performance of the code. These options enable developers to diagnose issues, analyze performance characteristics, and optimize parallel execution on multicore architectures. From enabling debug mode to specifying thread affinity and scheduling policies, users can tailor ExaNBody’s behavior to suit their specific requirements and achieve optimal performance. This section outlines the various command-line options available, empowering users to leverage ExaNBody’s capabilities effectively.</p>
<section id="command-line-and-input-file-interaction">
<h2><span class="section-number">8.1. </span>Command line and input file interaction<a class="headerlink" href="#command-line-and-input-file-interaction" title="Permalink to this heading"></a></h2>
<p>exaNBody based apps treat command line the same way as input files, the command line just being YAML elements expressed with another syntax.
YAML docuement, as processed by an exaNBody app is formed by a set of included files (either implicitly or explcitly through the <strong>includes</strong> list) and the user input file passed
as the first argument of command line, as in the following exemple :</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./exaStamp<span class="w"> </span>myinput.msp
</pre></div>
</div>
<p>The YAML document built from user input and its included files have 3 reserved dictionary entries, namely <strong>configuration</strong> reserved for configuring execution sub-system, <strong>includes</strong> reserved to include other YAML files
and <strong>simulation</strong> wich is interpreted as the the root batch operator representing the whole simulation to run.</p>
<p>When it comes to interpreting command line arguments, the exaNBody based application parses it and internally converts it to a YAML document, merged with previously read YAML inputs (user input file and included files). Conversion from command line argument to YAML proceeds as follows :</p>
<ul class="simple">
<li><p>If argument starts with <strong>–set-</strong>, it is understood as a generic YAML dictionary entry, and each ‘-’ is interpreted as a marker for an inner dictionary entry. The following value is understood as beeing the value associated with the given dictionary key. If no value found after a <strong>–set-xxx</strong> style argument, the value <strong>true</strong> is implicitly used. For instance, <strong>–set-global-rcut_inc ‘1.2 m’</strong> is equivalent to including a YAML file wich contains</p></li>
</ul>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">global</span><span class="p">:</span>
<span class="w">  </span><span class="nt">rcut_inc</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">1.2 m</span>
</pre></div>
</div>
<ul class="simple">
<li><p>If a command line argument starts with <strong>–xxx</strong> with xxx being anything but ‘set’ , then similar rules apply as for the <strong>–set-xxx</strong> args, but the YAML block is understood as being a dictionary entry inside the <strong>configuration</strong> block. For instance, <strong>–logging-debug true</strong> is equivalent to inclusion of a YAML file containing :</p></li>
</ul>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">configuration</span><span class="p">:</span>
<span class="w">  </span><span class="nt">logging</span><span class="p">:</span>
<span class="w">    </span><span class="nt">debug</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span>
</pre></div>
</div>
</section>
<section id="commands-help-for-your-application">
<h2><span class="section-number">8.2. </span>Commands ‘Help’ for your application<a class="headerlink" href="#commands-help-for-your-application" title="Permalink to this heading"></a></h2>
<p><cite>exaNBody</cite> provides several help commands to assist users in understanding the available command lines, plugins, and operators. Below are the descriptions and usage of each help command.</p>
<section id="general-help-command">
<h3><span class="section-number">8.2.1. </span>General Help Command<a class="headerlink" href="#general-help-command" title="Permalink to this heading"></a></h3>
<p>To display the general help information:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./exaDEM<span class="w"> </span>--help
</pre></div>
</div>
<p>This command shows the available help command lines.</p>
</section>
<section id="command-line-options-help">
<h3><span class="section-number">8.2.2. </span>Command-Line Options Help<a class="headerlink" href="#command-line-options-help" title="Permalink to this heading"></a></h3>
<p>To display the command line options available:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./exaDEM<span class="w"> </span>--help<span class="w"> </span>command-line
</pre></div>
</div>
<p>This command lists the command line options you can use to customize the configuration block. See the next section named “Index of command line options to customize configuration block” for detailed information.</p>
</section>
<section id="plugins-help">
<h3><span class="section-number">8.2.3. </span>Plugins Help<a class="headerlink" href="#plugins-help" title="Permalink to this heading"></a></h3>
<p>To print all operators and plugins available in your application:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./exaDEM<span class="w"> </span>--help<span class="w"> </span>plugins
</pre></div>
</div>
<p>This command prints every operator and plugin available in <cite>exaNBody</cite>.</p>
</section>
<section id="show-plugins-help">
<h3><span class="section-number">8.2.4. </span>Show Plugins Help<a class="headerlink" href="#show-plugins-help" title="Permalink to this heading"></a></h3>
<p>To show detailed information for every operator, including descriptions and slot operators:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./exaDEM<span class="w"> </span>--help<span class="w"> </span>show-plugins
</pre></div>
</div>
<p>This command provides detailed information for all operators, including their descriptions and slot operators.</p>
</section>
<section id="operator-specific-help">
<h3><span class="section-number">8.2.5. </span>Operator-Specific Help<a class="headerlink" href="#operator-specific-help" title="Permalink to this heading"></a></h3>
<p>To show details for a specific operator, including its description and slot operators:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./exaDEM<span class="w"> </span>--help<span class="w"> </span><span class="o">[</span>operator-name<span class="o">]</span>
</pre></div>
</div>
<p>Replace <cite>[operator-name]</cite> with the name of the operator you want details for.</p>
</section>
</section>
<section id="index-of-command-line-options-to-customize-configuration-block">
<h2><span class="section-number">8.3. </span>Index of command line options to customize configuration block<a class="headerlink" href="#index-of-command-line-options-to-customize-configuration-block" title="Permalink to this heading"></a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 27%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Option</p></th>
<th class="head"><p>Value type</p></th>
<th class="head"><p>Default</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>–logging-parallel</p></td>
<td><p>bool</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-odd"><td><p>–logging-debug</p></td>
<td><p>bool</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-even"><td><p>–logging-log_file</p></td>
<td><p>std::string</p></td>
<td><p>“”</p></td>
</tr>
<tr class="row-odd"><td><p>–logging-err_file</p></td>
<td><p>std::string</p></td>
<td><p>“”</p></td>
</tr>
<tr class="row-even"><td><p>–logging-dbg_file</p></td>
<td><p>std::string</p></td>
<td><p>“”</p></td>
</tr>
<tr class="row-odd"><td><p>–profiling-resmem</p></td>
<td><p>bool</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-even"><td><p>–profiling-exectime</p></td>
<td><p>bool</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-odd"><td><p>–profiling-summary</p></td>
<td><p>bool</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-even"><td><p>–profiling-filter</p></td>
<td><p>StringVector</p></td>
<td><p>{}</p></td>
</tr>
<tr class="row-odd"><td><p>–profilingtrace-enable</p></td>
<td><p>bool</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-even"><td><p>–profilingtrace-format</p></td>
<td><p>std::string</p></td>
<td><p>“yaml”</p></td>
</tr>
<tr class="row-odd"><td><p>–profilingtrace-file</p></td>
<td><p>std::string</p></td>
<td><p>“trace”</p></td>
</tr>
<tr class="row-even"><td><p>–profilingtrace-color</p></td>
<td><p>std::string</p></td>
<td><p>“operator”</p></td>
</tr>
<tr class="row-odd"><td><p>–profilingtrace-total</p></td>
<td><p>bool</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-even"><td><p>–profilingtrace-idle</p></td>
<td><p>bool</p></td>
<td><p>true</p></td>
</tr>
<tr class="row-odd"><td><p>–profilingtrace-trigger</p></td>
<td><p>std::string</p></td>
<td><p>“”</p></td>
</tr>
<tr class="row-even"><td><p>–profilingtrace-trigger_interval</p></td>
<td><p>IntVector</p></td>
<td><p>{}</p></td>
</tr>
<tr class="row-odd"><td><p>–profilingtrace-idle_resolution</p></td>
<td><p>long</p></td>
<td><p>8192</p></td>
</tr>
<tr class="row-even"><td><p>–profilingtrace-idle_smoothing</p></td>
<td><p>long</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>–debug-plugins</p></td>
<td><p>bool</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-even"><td><p>–debug-config</p></td>
<td><p>bool</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-odd"><td><p>–debug-yaml</p></td>
<td><p>bool</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-even"><td><p>–debug-graph</p></td>
<td><p>bool</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-odd"><td><p>–debug-ompt</p></td>
<td><p>bool</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-even"><td><p>–debug-graph_addr</p></td>
<td><p>bool</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-odd"><td><p>–debug-graph_lod</p></td>
<td><p>int</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>–debug-graph_fmt</p></td>
<td><p>std::string</p></td>
<td><p>“console”</p></td>
</tr>
<tr class="row-odd"><td><p>–debug-graph_rsc</p></td>
<td><p>bool</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-even"><td><p>–debug-files</p></td>
<td><p>bool</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-odd"><td><p>–debug-rng</p></td>
<td><p>std::string</p></td>
<td><p>“”</p></td>
</tr>
<tr class="row-even"><td><p>–debug-graph_filter</p></td>
<td><p>StringVector</p></td>
<td><p>{}</p></td>
</tr>
<tr class="row-odd"><td><p>–debug-filter</p></td>
<td><p>StringVector</p></td>
<td><p>{}</p></td>
</tr>
<tr class="row-even"><td><p>–debug-particle</p></td>
<td><p>UInt64Vector</p></td>
<td><p>{}</p></td>
</tr>
<tr class="row-odd"><td><p>–debug-particle_nbh</p></td>
<td><p>bool</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-even"><td><p>–debug-particle_ghost</p></td>
<td><p>bool</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-odd"><td><p>–debug-fpe</p></td>
<td><p>bool</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-even"><td><p>–debug-verbose</p></td>
<td><p>int</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>–debug-graph_exec</p></td>
<td><p>bool</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-even"><td><p>–onika-parallel_task_core_mult</p></td>
<td><p>int</p></td>
<td><p>ONIKA_TASKS_PER_CORE</p></td>
</tr>
<tr class="row-odd"><td><p>–onika-parallel_task_core_add</p></td>
<td><p>int</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>–onika-gpu_sm_mult</p></td>
<td><p>int</p></td>
<td><p>ONIKA_CU_MIN_BLOCKS_PER_SM</p></td>
</tr>
<tr class="row-odd"><td><p>–onika-gpu_sm_add</p></td>
<td><p>int</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>–onika-gpu_block_size</p></td>
<td><p>int</p></td>
<td><p>ONIKA_CU_MAX_THREADS_PER_BLOCK</p></td>
</tr>
<tr class="row-odd"><td><p>–onika-gpu_disable_filter</p></td>
<td><p>StringVector</p></td>
<td><p>{}</p></td>
</tr>
<tr class="row-even"><td><p>–nogpu</p></td>
<td><p>bool</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-odd"><td><p>–mpimt</p></td>
<td><p>bool</p></td>
<td><p>true</p></td>
</tr>
<tr class="row-even"><td><p>–pinethreads</p></td>
<td><p>bool</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-odd"><td><p>–threadrotate</p></td>
<td><p>int</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>–omp_num_threads</p></td>
<td><p>int</p></td>
<td><p>-1</p></td>
</tr>
<tr class="row-odd"><td><p>–omp_max_nesting</p></td>
<td><p>int</p></td>
<td><p>-1</p></td>
</tr>
<tr class="row-even"><td><p>–omp_nested</p></td>
<td><p>bool</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-odd"><td><p>–plugin_dir</p></td>
<td><p>std::string</p></td>
<td><p>USTAMP_PLUGIN_DIR</p></td>
</tr>
<tr class="row-even"><td><p>–plugin_db</p></td>
<td><p>std::string</p></td>
<td><p>“”</p></td>
</tr>
<tr class="row-odd"><td><p>–plugins</p></td>
<td><p>StringVector</p></td>
<td><p>{}</p></td>
</tr>
<tr class="row-even"><td><p>–generate_plugins_db</p></td>
<td><p>bool</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-odd"><td><p>–help</p></td>
<td><p>std::string</p></td>
<td><p>“”</p></td>
</tr>
<tr class="row-even"><td><p>–run_unit_tests</p></td>
<td><p>bool</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-odd"><td><p>–set</p></td>
<td><p>YAML::Node</p></td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="tune-your-run-with-openmp">
<h2><span class="section-number">8.4. </span>Tune your run with OpenMP<a class="headerlink" href="#tune-your-run-with-openmp" title="Permalink to this heading"></a></h2>
<p>Harnessing the power of OpenMP parallelization, ExaNBody provides users with the ability to fine-tune their execution environment for optimal performance on multicore architectures. Through a selection of command-line options, users can customize thread management, affinity settings, and loop scheduling to maximize parallel efficiency. This subsection introduces the command-line options available for configuring OpenMP behavior within ExaNBody.</p>
<table class="docutils align-default" id="id6">
<caption><span class="caption-text">ExaNBody OpenMP Command Lines</span><a class="headerlink" href="#id6" title="Permalink to this table"></a></caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 20%" />
<col style="width: 45%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Type of tools</p></th>
<th class="head"><p>Command line</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Default</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Pine OMP Threads</p></td>
<td><p>–pinethreads true</p></td>
<td><p>Controls thread affinity settings within the OpenMP runtime, influencing how threads are bound to CPU cores for improved performance, particularly on NUMA architectures.</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-odd"><td><p>Set the number of threads</p></td>
<td><p>–omp_num_threads 10</p></td>
<td><p>Specifies the number of threads to be utilized for parallel execution, allowing users to control the degree of parallelism based on system resources and workload characteristics.</p></td>
<td><p>By default it takes the maximum number of threads available</p></td>
</tr>
<tr class="row-even"><td><p>Maximum level of nested parallelism</p></td>
<td><p>–omp_max_nesting [max_nesting_level]</p></td>
<td><p>Specifies the maximum level of nested parallelism allowed within OpenMP, controlling the depth at which parallel regions can be nested.</p></td>
<td><p>-1</p></td>
</tr>
<tr class="row-odd"><td><p>Nested parallelism within OpenMP</p></td>
<td><p>–omp_nested [true/false]</p></td>
<td><p>Enables or disables nested parallelism within OpenMP, allowing parallel regions to spawn additional parallel regions. true may be replaced by an integer indicating how many nested parallelism levels are allowed.</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-even"><td><p>MPI_THREAD_MULTIPLE feature request</p></td>
<td><p>–mpimt [true|false]</p></td>
<td><p>If set to true, requires that MPI implementation supports MPI_THREAD_MULTIPLE feature</p></td>
<td><p>true</p></td>
</tr>
</tbody>
</table>
</section>
<section id="tune-gpu-execution-options">
<h2><span class="section-number">8.5. </span>Tune GPU execution options<a class="headerlink" href="#tune-gpu-execution-options" title="Permalink to this heading"></a></h2>
<p>Harnessing the power of GPU parallelization, ExaNBody provides users with the ability to fine-tune their execution environment for optimal performance on GPU accelerators. Through a selection of command-line options, users can customize GPU configuration management.</p>
<table class="docutils align-default" id="id7">
<caption><span class="caption-text">ExaNBody GPU Command Lines</span><a class="headerlink" href="#id7" title="Permalink to this table"></a></caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 20%" />
<col style="width: 45%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Type of tools</p></th>
<th class="head"><p>Command line</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Default</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>disable GPU</p></td>
<td><p>–nogpu</p></td>
<td><p>disbales use of GPU accelerators, even though some are available.</p></td>
<td><p>false</p></td>
</tr>
<tr class="row-odd"><td><p>workgroup / block size</p></td>
<td><p>–onika-gpu_block_size N</p></td>
<td><p>sets default thread block size to N.</p></td>
<td><p>128</p></td>
</tr>
<tr class="row-even"><td><p>selectively disable GPU</p></td>
<td><p>–onika-gpu_disable_filter [ “sim.loop.compute_force.hook_force” , “.*hook_force” ]</p></td>
<td><p>a list of regular expressions matching operator paths for which GPU execution will be disabled</p></td>
<td><p>[]</p></td>
</tr>
</tbody>
</table>
</section>
<section id="profiling-tools-available-in-exanbody">
<h2><span class="section-number">8.6. </span>Profiling tools available in exaNBody<a class="headerlink" href="#profiling-tools-available-in-exanbody" title="Permalink to this heading"></a></h2>
<p>ExaNBody offers a comprehensive suite of performance profiling tools designed to empower users in analyzing and optimizing their parallel applications. These tools provide valuable insights into runtime behavior, resource utilization, and performance bottlenecks, enabling developers to fine-tune their code for maximum efficiency. From CPU profiling to memory analysis, ExaNBody’s profiling tools offer a range of capabilities to meet diverse profiling needs. This section introduces the profiling tools available within ExaNBody, equipping users with the means to gain deeper understanding and enhance the performance of their parallel applications. some profiling tools are accessible through conifguration flags, others need to insert specific operator nodes in simulation description.</p>
<table class="docutils align-default" id="id8">
<caption><span class="caption-text">ExaNBody Profiling Tools Command Lines</span><a class="headerlink" href="#id8" title="Permalink to this table"></a></caption>
<colgroup>
<col style="width: 15%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Type of tools</p></th>
<th class="head"><p>Command line / Operator</p></th>
<th class="head"><p>Defaults</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Timers (configuration flag)</p></td>
<td><p>–profiling-summary [true|false]</p></td>
<td><p>true</p></td>
<td><p>Displays timer informtaions for every bottom level or batch operator nodes in simaulation graph. if two percentages are shown, second one is the portion of time spent in the nearest enclosing loop batch operator (i.e. compute_loop)</p></td>
</tr>
<tr class="row-odd"><td><p>VITE Trace (configuration flag)</p></td>
<td><p>–profilingtrace-file [true|false]</p></td>
<td><p>“”</p></td>
<td><p>Generates a VITE trace describing CPU threads occupation (not available GPU threads).</p></td>
</tr>
<tr class="row-even"><td><p>Resident memory (configuration flag)</p></td>
<td><p>–profiling-resmem [true|false]</p></td>
<td><p>false</p></td>
<td><p>Displays resident memory evolution during the execution. Helps tracking of memory leaks.</p></td>
</tr>
<tr class="row-odd"><td><p>Performance adviser (operator)</p></td>
<td><p>not present by default, can be inserted after initialization phase or after first iteration, i.e. using +first_iteration: [ perfomance_advisor ]</p></td>
<td><p>performance_adviser: { verbose: true }</p></td>
<td><p>Displays some tips about parameters to be tweaked to improve your simulations performance (cell size, number of MPI processes, etc.)</p></td>
</tr>
</tbody>
</table>
</section>
<section id="using-timers-with-mpi-and-gpu">
<h2><span class="section-number">8.7. </span>Using Timers with MPI and GPU<a class="headerlink" href="#using-timers-with-mpi-and-gpu" title="Permalink to this heading"></a></h2>
<p>In ExaNBody, timers are essential tools for measuring performance in MPI and GPU-accelerated computations. This section explores their use within ExaNBody’s parallel implementations, providing insights into runtime behavior and performance characteristics.</p>
<dl class="simple">
<dt>This tools provides the list of timers for every operators in a hierarchical form.</dt><dd><ul class="simple">
<li><p>Number of calls</p></li>
<li><p>CPU Time</p></li>
<li><p>GPU Time</p></li>
<li><p>Imbalance time between mpi processes (average and maximum)</p></li>
<li><p>execution time ratio</p></li>
</ul>
</dd>
</dl>
<p>The Imbalance value is computed as :
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">I</span> <span class="pre">=</span> <span class="pre">(T_max</span> <span class="pre">-</span> <span class="pre">T_ave)/T_ave</span> <span class="pre">-</span> <span class="pre">1</span>
<span class="pre">`</span></code></p>
<dl class="simple">
<dt>With the variables:</dt><dd><ul class="simple">
<li><p><cite>T_max</cite> is the execution time of the slowest MPI process.</p></li>
<li><p><cite>T_ave</cite> is the average time spent over MPI processes.</p></li>
<li><p><cite>I</cite> is the imbalance value.</p></li>
</ul>
</dd>
</dl>
<p>Note that if you force to stop your simulation, the timer are automatically printed in your terminal.</p>
<p>Output with OpenMP:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Profiling<span class="w"> </span>.........................................<span class="w">  </span>tot.<span class="w"> </span><span class="nb">time</span><span class="w">  </span><span class="o">(</span><span class="w"> </span>GPU<span class="w"> </span><span class="o">)</span><span class="w">   </span>avginb<span class="w">  </span>maxinb<span class="w">     </span>count<span class="w">  </span>percent
sim<span class="w"> </span>...............................................<span class="w">  </span><span class="m">2</span>.967e+04<span class="w">            </span><span class="m">0</span>.000<span class="w">   </span><span class="m">0</span>.000<span class="w">         </span><span class="m">1</span><span class="w">  </span><span class="m">100</span>.00%
...<span class="w"> </span>//<span class="w"> </span>some<span class="w"> </span>logs
<span class="w">  </span>loop<span class="w"> </span>............................................<span class="w">  </span><span class="m">2</span>.964e+04<span class="w">            </span><span class="m">0</span>.000<span class="w">   </span><span class="m">0</span>.000<span class="w">         </span><span class="m">1</span><span class="w">  </span><span class="m">99</span>.88%
<span class="w">    </span>scheme<span class="w"> </span>........................................<span class="w">  </span><span class="m">2</span>.881e+04<span class="w">            </span><span class="m">0</span>.000<span class="w">   </span><span class="m">0</span>.000<span class="w">    </span><span class="m">100000</span><span class="w">  </span><span class="m">97</span>.09%
<span class="w">      </span>combined_compute_prolog<span class="w"> </span>.....................<span class="w">  </span><span class="m">2</span>.300e+03<span class="w">            </span><span class="m">0</span>.000<span class="w">   </span><span class="m">0</span>.000<span class="w">    </span><span class="m">100000</span><span class="w">   </span><span class="m">7</span>.75%
<span class="w">      </span>check_and_update_particles<span class="w"> </span>..................<span class="w">  </span><span class="m">1</span>.016e+04<span class="w">            </span><span class="m">0</span>.000<span class="w">   </span><span class="m">0</span>.000<span class="w">    </span><span class="m">100000</span><span class="w">  </span><span class="m">34</span>.25%
<span class="w">        </span>particle_displ_over<span class="w"> </span>.......................<span class="w">  </span><span class="m">2</span>.154e+03<span class="w">            </span><span class="m">0</span>.000<span class="w">   </span><span class="m">0</span>.000<span class="w">    </span><span class="m">100000</span><span class="w">   </span><span class="m">7</span>.26%
<span class="w">        </span>update_particles_full<span class="w"> </span>.....................<span class="w">  </span><span class="m">6</span>.482e+03<span class="w">            </span><span class="m">0</span>.000<span class="w">   </span><span class="m">0</span>.000<span class="w">      </span><span class="m">5961</span><span class="w">  </span><span class="m">21</span>.84%
<span class="w">          </span>update_particles_full_body<span class="w"> </span>..............<span class="w">  </span><span class="m">6</span>.474e+03<span class="w">            </span><span class="m">0</span>.000<span class="w">   </span><span class="m">0</span>.000<span class="w">      </span><span class="m">5961</span><span class="w">  </span><span class="m">21</span>.82%
<span class="w">            </span>compact_neighbor_friction<span class="w"> </span>.............<span class="w">  </span><span class="m">1</span>.621e+02<span class="w">            </span><span class="m">0</span>.000<span class="w">   </span><span class="m">0</span>.000<span class="w">      </span><span class="m">5961</span><span class="w">   </span><span class="m">0</span>.55%
<span class="w">            </span>move_particles_friction<span class="w"> </span>...............<span class="w">  </span><span class="m">6</span>.347e+02<span class="w">            </span><span class="m">0</span>.000<span class="w">   </span><span class="m">0</span>.000<span class="w">      </span><span class="m">5961</span><span class="w">   </span><span class="m">2</span>.14%
<span class="w">            </span>trigger_load_balance<span class="w"> </span>..................<span class="w">  </span><span class="m">2</span>.591e+02<span class="w">            </span><span class="m">0</span>.000<span class="w">   </span><span class="m">0</span>.000<span class="w">      </span><span class="m">5961</span><span class="w">   </span><span class="m">0</span>.87%
<span class="w">              </span>trigger_lb_tmp<span class="w"> </span>......................<span class="w">  </span><span class="m">6</span>.095e+00<span class="w">            </span><span class="m">0</span>.000<span class="w">   </span><span class="m">0</span>.000<span class="w">      </span><span class="m">5961</span><span class="w">   </span><span class="m">0</span>.02%
<span class="w">                </span>nth_timestep<span class="w"> </span>......................<span class="w">  </span><span class="m">3</span>.342e+00<span class="w">            </span><span class="m">0</span>.000<span class="w">   </span><span class="m">0</span>.000<span class="w">      </span><span class="m">5961</span><span class="w">   </span><span class="m">0</span>.01%
<span class="w">              </span>extend_domain<span class="w"> </span>.......................<span class="w">  </span><span class="m">2</span>.389e+02<span class="w">            </span><span class="m">0</span>.000<span class="w">   </span><span class="m">0</span>.000<span class="w">      </span><span class="m">5961</span><span class="w">   </span><span class="m">0</span>.80%
...
</pre></div>
</div>
<p>Output with MPI:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Profiling<span class="w"> </span>.........................................<span class="w">  </span>tot.<span class="w"> </span><span class="nb">time</span><span class="w">  </span><span class="o">(</span><span class="w"> </span>GPU<span class="w"> </span><span class="o">)</span><span class="w">   </span>avginb<span class="w">  </span>maxinb<span class="w">     </span>count<span class="w">  </span>percent
sim<span class="w"> </span>...............................................<span class="w">  </span><span class="m">2</span>.376e+04<span class="w">            </span><span class="m">0</span>.000<span class="w">   </span><span class="m">0</span>.000<span class="w">         </span><span class="m">1</span><span class="w">  </span><span class="m">100</span>.00%
...<span class="w"> </span>//<span class="w"> </span>some<span class="w"> </span>logs
<span class="w">  </span>loop<span class="w"> </span>............................................<span class="w">  </span><span class="m">2</span>.372e+04<span class="w">            </span><span class="m">0</span>.000<span class="w">   </span><span class="m">0</span>.000<span class="w">         </span><span class="m">1</span><span class="w">  </span><span class="m">99</span>.82%
<span class="w">    </span>scheme<span class="w"> </span>........................................<span class="w">  </span><span class="m">2</span>.308e+04<span class="w">            </span><span class="m">0</span>.086<span class="w">   </span><span class="m">2</span>.249<span class="w">    </span><span class="m">100000</span><span class="w">  </span><span class="m">97</span>.13%
<span class="w">      </span>combined_compute_prolog<span class="w"> </span>.....................<span class="w">  </span><span class="m">5</span>.779e+02<span class="w">            </span><span class="m">0</span>.280<span class="w">   </span><span class="m">2</span>.937<span class="w">    </span><span class="m">100000</span><span class="w">   </span><span class="m">2</span>.43%
<span class="w">      </span>check_and_update_particles<span class="w"> </span>..................<span class="w">  </span><span class="m">1</span>.687e+04<span class="w">            </span><span class="m">0</span>.454<span class="w">   </span><span class="m">2</span>.770<span class="w">    </span><span class="m">100000</span><span class="w">  </span><span class="m">70</span>.97%
<span class="w">        </span>particle_displ_over<span class="w"> </span>.......................<span class="w">  </span><span class="m">4</span>.067e+03<span class="w">            </span><span class="m">0</span>.687<span class="w">   </span><span class="m">2</span>.643<span class="w">    </span><span class="m">100000</span><span class="w">  </span><span class="m">17</span>.11%
<span class="w">        </span>update_particles_full<span class="w"> </span>.....................<span class="w">  </span><span class="m">1</span>.159e+04<span class="w">            </span><span class="m">0</span>.167<span class="w">   </span><span class="m">0</span>.812<span class="w">      </span><span class="m">6001</span><span class="w">  </span><span class="m">48</span>.78%
<span class="w">          </span>update_particles_full_body<span class="w"> </span>..............<span class="w">  </span><span class="m">1</span>.159e+04<span class="w">            </span><span class="m">0</span>.167<span class="w">   </span><span class="m">0</span>.813<span class="w">      </span><span class="m">6001</span><span class="w">  </span><span class="m">48</span>.76%
<span class="w">            </span>compact_neighbor_friction<span class="w"> </span>.............<span class="w">  </span><span class="m">7</span>.170e+01<span class="w">            </span><span class="m">0</span>.387<span class="w">   </span><span class="m">0</span>.876<span class="w">      </span><span class="m">6001</span><span class="w">   </span><span class="m">0</span>.30%
<span class="w">            </span>move_particles_friction<span class="w"> </span>...............<span class="w">  </span><span class="m">1</span>.797e+02<span class="w">            </span><span class="m">0</span>.254<span class="w">   </span><span class="m">0</span>.853<span class="w">      </span><span class="m">6001</span><span class="w">   </span><span class="m">0</span>.76%
<span class="w">            </span>trigger_load_balance<span class="w"> </span>..................<span class="w">  </span><span class="m">9</span>.340e+01<span class="w">            </span><span class="m">0</span>.674<span class="w">   </span><span class="m">1</span>.787<span class="w">      </span><span class="m">6001</span><span class="w">   </span><span class="m">0</span>.39%
<span class="w">              </span>trigger_lb_tmp<span class="w"> </span>......................<span class="w">  </span><span class="m">2</span>.582e+00<span class="w">            </span><span class="m">0</span>.187<span class="w">   </span><span class="m">2</span>.836<span class="w">      </span><span class="m">6001</span><span class="w">   </span><span class="m">0</span>.01%
<span class="w">                </span>nth_timestep
<span class="w">              </span>extend_domain<span class="w"> </span>.......................<span class="w">  </span><span class="m">8</span>.655e+01<span class="w">            </span><span class="m">0</span>.733<span class="w">   </span><span class="m">2</span>.016<span class="w">      </span><span class="m">6001</span><span class="w">   </span><span class="m">0</span>.36%
...
</pre></div>
</div>
</section>
<section id="debug-features-in-exanbody">
<h2><span class="section-number">8.8. </span>Debug features in exaNBody<a class="headerlink" href="#debug-features-in-exanbody" title="Permalink to this heading"></a></h2>
<p>ExaNBody is equipped with a range of debug features tailored to aid developers in the debugging process. This section outlines the comprehensive list of debug functionalities available within ExaNBody, providing developers with essential tools to diagnose and resolve issues effectively. This is an exhaustive list:</p>
<table class="docutils align-default" id="id9">
<caption><span class="caption-text">ExaNBody Debug Command Lines</span><a class="headerlink" href="#id9" title="Permalink to this table"></a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 40%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Type of tools</p></th>
<th class="head"><p>Command line</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Simulation graph</p></td>
<td><p>–debug-graph [true|false]</p></td>
<td><p>Prints simulation graph as built after user input file, included files and command lines are processed</p></td>
</tr>
<tr class="row-odd"><td><p>user input YAML document</p></td>
<td><p>–debug-yaml [true|false]</p></td>
<td><p>Prints final YAML document used by application after user input file, included files and command lines are merged</p></td>
</tr>
<tr class="row-even"><td><p>Output ldbg</p></td>
<td><p>–logging-debug true</p></td>
<td><p>Print debug logs added in <cite>ldbg &lt;&lt;</cite></p></td>
</tr>
<tr class="row-odd"><td><p>filtering debug output</p></td>
<td><p>–debug-filter [“regexp1”,”regexp2”,…]</p></td>
<td><p>Filters which operator nodes output debug messges with ldbg&lt;&lt;”…”. regexp is a regular expression matching operator pathname, i.e. it’s name within block and sub block, for instance “sim.first_iteration.compute_force.lj_force” can be filtered differently than sim.compute_loop.compute_force.lj_force”. alternatively, adding a filter expression such as “.*lj_force” will activate debug messages for all instances of lj_force operator.</p></td>
</tr>
</tbody>
</table>
<p>How to use output ldbg:</p>
<dl class="simple">
<dt>Possiblity to active it only for one operator:</dt><dd><ul class="simple">
<li><p>Command line : <cite>–logging-debug true –debug-filter[“.*operator1”,”.*operator2”,…]</cite></p></li>
<li><p>Operator name : logging and debug</p></li>
</ul>
</dd>
</dl>
<p>Example in your input file (.msp):</p>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">configuration</span><span class="p">:</span>
<span class="w">  </span><span class="nt">logging</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">{</span><span class="nt"> debug</span><span class="p">:</span><span class="w"> </span><span class="nv">false</span><span class="w"> </span><span class="p p-Indicator">,</span><span class="nt"> parallel</span><span class="p">:</span><span class="w"> </span><span class="nv">true</span><span class="w"> </span><span class="p p-Indicator">}</span>
<span class="w">  </span><span class="nt">debug</span><span class="p">:</span>
<span class="w">    </span><span class="nt">filter</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="w"> </span><span class="s">&quot;.*init_neighbor_friction&quot;</span><span class="w"> </span><span class="p p-Indicator">,</span><span class="w"> </span><span class="s">&quot;.*move_particles_friction&quot;</span><span class="w"> </span><span class="p p-Indicator">,</span><span class="w"> </span><span class="s">&quot;.*check_nbh_friction&quot;</span><span class="w"> </span><span class="p p-Indicator">,</span><span class="w"> </span><span class="s">&quot;.*compact_neighbor_friction&quot;</span><span class="w"> </span><span class="p p-Indicator">,</span><span class="w"> </span><span class="s">&quot;.*extend_domain&quot;</span><span class="w"> </span><span class="p p-Indicator">]</span>
</pre></div>
</div>
</section>
</section>
<section id="tutorials">
<h1><span class="section-number">9. </span>Tutorials<a class="headerlink" href="#tutorials" title="Permalink to this heading"></a></h1>
<section id="add-a-new-plugin">
<h2><span class="section-number">9.1. </span>Add a new plugin<a class="headerlink" href="#add-a-new-plugin" title="Permalink to this heading"></a></h2>
<p>You can create new plugins if you wish to develop a new set of operators that can be compiled independently of others or require specific plugin compilation. Here’s how to define and add a new plugin.</p>
<p>First of all, add your new plugin directory in <cite>src/CMakeLists.txt</cite>:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>mkdir<span class="w"> </span>my_new_plugin
add_subdirectory<span class="o">(</span>my_new_plugin<span class="o">)</span>
<span class="nb">cd</span><span class="w"> </span>my_new_plugin
vi<span class="w"> </span>CMakeLists.txt
</pre></div>
</div>
<p>Create a CMakeLists.txt and use the macros defined to plug your operators to exaNBody support such as:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>set<span class="o">(</span>list_of_plugins_required<span class="w"> </span>exanbIO<span class="w"> </span>exanbDefBox<span class="w"> </span>exanbParticleNeighbors<span class="w"> </span>exadem_numerical_scheme<span class="w"> </span>exadem_friction<span class="w"> </span>exadem_force_field<span class="o">)</span>
set<span class="o">(</span>exadem_my_new_plugin_LINK_LIBRARIES<span class="w"> </span><span class="si">${</span><span class="nv">list_of_plugins_required</span><span class="si">}</span><span class="o">)</span>
xstamp_add_plugin<span class="o">(</span>exadem_my_new_plugin<span class="w"> </span><span class="si">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="si">}</span><span class="o">)</span>
</pre></div>
</div>
<p>Warning: Do not forget to do a <cite>make UpdatePluginDataBase</cite>.</p>
</section>
<section id="add-a-new-operator">
<h2><span class="section-number">9.2. </span>Add a new operator<a class="headerlink" href="#add-a-new-operator" title="Permalink to this heading"></a></h2>
<p>Initially, it’s crucial to establish a precise definition of the intended kernel, the targeted data, and the method for executing this kernel.</p>
<section id="define-your-kernel">
<h3><span class="section-number">9.2.1. </span>Define your kernel<a class="headerlink" href="#define-your-kernel" title="Permalink to this heading"></a></h3>
<p>We recommend writing the computation kernel (in a functor) in a <cite>.h</cite> file within an <cite>include/exaDEM</cite> folder of your plugin directory. For instance, if one intends to apply gravitational force to a particle, it’s necessary to have knowledge of the external force and access to mutators for modifying the force fields. The kernel for a particle is then written in a file <cite>include/exaDEM/gravity_force.h</cite>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">exaDEM</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">GravityForceFunctor</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">exanb</span><span class="o">::</span><span class="n">Vec3d</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="mf">-9.807</span><span class="p">};</span>
<span class="w">    </span><span class="n">ONIKA_HOST_DEVICE_FUNC</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">mass</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fx</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fy</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fz</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">fx</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mass</span><span class="p">;</span>
<span class="w">      </span><span class="n">fy</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mass</span><span class="p">;</span>
<span class="w">      </span><span class="n">fz</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mass</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It is possible to provide specific kernel <cite>Traits</cite> that will be used by the data traversal functions (ex: <cite>ComputeCellParticles</cite>). For example, if we want to provide the GPU capabilities for this kernel:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">exanb</span>
<span class="p">{</span>
<span class="k">template</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">ComputeCellParticlesTraits</span><span class="o">&lt;</span><span class="n">exaDEM</span><span class="o">::</span><span class="n">GravityForceFunctor</span><span class="o">&gt;</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">CudaCompatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="define-an-operator">
<h3><span class="section-number">9.2.2. </span>Define an operator:<a class="headerlink" href="#define-an-operator" title="Permalink to this heading"></a></h3>
<p>To begin with, all operators inherit from the OperatorNode class, where you establish the necessary physical fields for applying your operator. Following that, it’s essential to define the slots that will establish the execution graph among operators. Ultimately, you are required to furnish an Execute() function, which the graph will execute, along with a Documentation() function.</p>
<p>This is an example of an empty operator:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;exaDEM/your_kernel.h&gt;</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">exaDEM</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">exanb</span><span class="p">;</span>
<span class="w">  </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">GridT</span>
<span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AssertGridHasFields</span><span class="o">&lt;</span><span class="w"> </span><span class="n">GridT</span><span class="p">,</span><span class="w"> </span><span class="n">list_of_fields</span><span class="o">&gt;</span>
<span class="w">    </span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">class</span><span class="w"> </span><span class="nc">YourOperator</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">OperatorNode</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">ComputeFields</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FieldSet</span><span class="o">&lt;</span><span class="w"> </span><span class="n">list_of_fields</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">ComputeFields</span><span class="w"> </span><span class="n">compute_field_set</span><span class="w"> </span><span class="p">{};</span>
<span class="w">    </span><span class="n">ADD_SLOT</span><span class="p">(</span><span class="w"> </span><span class="n">GridT</span><span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">grid</span><span class="w">     </span><span class="p">,</span><span class="w"> </span><span class="n">INPUT_OUTPUT</span><span class="w"> </span><span class="p">);</span>
<span class="w">  </span><span class="k">public</span><span class="o">:</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">documentation</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">final</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="sa">R</span><span class="s">&quot;</span><span class="dl">EOF(</span><span class="s">Your operator.</span><span class="dl">)EOF</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">execute</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">final</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">YourFunctor</span><span class="w"> </span><span class="n">func</span><span class="p">;</span>
<span class="w">      </span><span class="n">compute_cell_particles</span><span class="p">(</span><span class="w"> </span><span class="o">*</span><span class="n">grid</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">func</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">compute_field_set</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">gpu_execution_context</span><span class="p">()</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">gpu_time_account_func</span><span class="p">()</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">GridT</span><span class="o">&gt;</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">YourOperatorTmpl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">YourOperator</span><span class="o">&lt;</span><span class="n">GridT</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// === register factories ===</span>
<span class="w">  </span><span class="n">CONSTRUCTOR_FUNCTION</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">OperatorNodeFactory</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">register_factory</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;your_operator_name&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">make_grid_variant_operator</span><span class="o">&lt;</span><span class="w"> </span><span class="n">YourOperatorTmpl</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="comments">
<h4><span class="section-number">9.2.2.1. </span>Comments:<a class="headerlink" href="#comments" title="Permalink to this heading"></a></h4>
<ul class="simple">
<li><p>Please refers to <cite>src/forcefields/gravity_force.cpp</cite> to illustrate a simple example.</p></li>
<li><p>AssertGridHasFields allows to eliminate wrong grids</p></li>
<li><p>If <cite>ComputeFields</cite> does not correspond to the input parameters of your functor, the operator can’t compile.</p></li>
<li><dl class="simple">
<dt>ADD_SLOT macro works as <cite>ADD_SLOT(Type, Name, TypeOfSlot, DefaultValue, Documentation)</cite> with:</dt><dd><ul>
<li><p>Type: <cite>double</cite>, <cite>int</cite> …</p></li>
<li><p>TypeOfSlot: <cite>INPUT</cite>, <cite>OUTPUT</cite> or <cite>INPUT_OUTPUT</cite></p></li>
<li><p>Documentation: is a DocString type: <cite>DocString{slot documentation}</cite></p></li>
</ul>
</dd>
</dl>
</li>
<li><p>To access to a slot value, please add <cite>*</cite>.</p></li>
<li><p>Constant value are hidden the operator, for example the gravity functor is initialized as: <cite>GravityForceFunctor func { *gravity};</cite>, gravity is a slot.</p></li>
<li><p>Note that you need to specify you operator for a given Grid and define the <cite>operator_name</cite> in your dictionnary.</p></li>
</ul>
</section>
<section id="comment">
<h4><span class="section-number">9.2.2.2. </span>Comment:<a class="headerlink" href="#comment" title="Permalink to this heading"></a></h4>
<p>You can do your own traversal function by explicitely iterating over cells. Example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ADD_SLOT</span><span class="p">(</span><span class="w"> </span><span class="n">GridT</span><span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="n">grid</span><span class="w">            </span><span class="p">,</span><span class="w"> </span><span class="n">INPUT_OUTPUT</span><span class="w"> </span><span class="p">);</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">execute</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="k">final</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">MPI_Comm</span><span class="w"> </span><span class="n">comm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">mpi</span><span class="p">;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">cells</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">grid</span><span class="o">-&gt;</span><span class="n">cells</span><span class="p">();</span>
<span class="w">  </span><span class="n">IJK</span><span class="w"> </span><span class="n">dims</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">grid</span><span class="o">-&gt;</span><span class="n">dimension</span><span class="p">();</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">ghost_layers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">grid</span><span class="o">-&gt;</span><span class="n">ghost_layers</span><span class="p">();</span>
<span class="w">  </span><span class="n">IJK</span><span class="w"> </span><span class="n">dims_no_ghost</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dims</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">ghost_layers</span><span class="p">);</span>
<span class="cp"># pragma omp parallel</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">GRID_OMP_FOR_BEGIN</span><span class="p">(</span><span class="n">dims_no_ghost</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">loc_no_ghosts</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">IJK</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">loc_no_ghosts</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ghost_layers</span><span class="p">;</span>
<span class="w">      </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cell_i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">grid_ijk_to_index</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span><span class="n">loc</span><span class="p">);</span>
<span class="w">      </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cell_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cells</span><span class="p">[</span><span class="n">cell_i</span><span class="p">];</span>
<span class="w">      </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cells</span><span class="p">[</span><span class="n">cell_i</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
<span class="w">      </span><span class="k">auto</span><span class="o">*</span><span class="w"> </span><span class="n">__restrict__</span><span class="w"> </span><span class="n">_my_field</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell_ptr</span><span class="p">[</span><span class="n">field</span><span class="o">::</span><span class="n">my_field</span><span class="p">];</span>
<span class="cp">#     pragma omp simd</span>
<span class="w">      </span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">_my_field</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">27</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
</section>
</section>
<section id="exanbody-publications">
<h1><span class="section-number">10. </span>ExaNBody Publications:<a class="headerlink" href="#exanbody-publications" title="Permalink to this heading"></a></h1>
<p>Main citation:</p>
<p>Carrard, T., Prat, R., Latu, G., Babilotte, K., Lafourcade, P., Amarsid, L., &amp; Soulard, L. (2023). ExaNBody: a HPC framework for N-Body applications. <a class="reference internal" href="bibliography.html#carrard2023"><span class="std std-ref">(Carrard)</span></a></p>
<p>Field High Performance Computing:</p>
<p>Carrard, T., Prat, R., Latu, G., Babilotte, K., Lafourcade, P., Amarsid, L., &amp; Soulard, L. (2023). ExaNBody: a HPC framework for N-Body applications. <a class="reference internal" href="bibliography.html#carrard2023"><span class="std std-ref">(Carrard)</span></a></p>
<p>Prat, R., Carrard, T., Soulard, L., Durand, O., Namyst, R., &amp; Colombet, L. (2020). AMR-based molecular dynamics for non-uniform, highly dynamic particle simulations. Computer Physics Communications, 253, 107177.</p>
<p>Prat, R., Colombet, L., &amp; Namyst, R. (2018, August). Combining task-based parallelism and adaptive mesh refinement techniques in molecular dynamics simulations. In Proceedings of the 47th International Conference on Parallel Processing (pp. 1-10).</p>
<p>Dirand, E., Colombet, L., &amp; Raffin, B. (2018). Tins: A task-based dynamic helper core strategy for in situ analytics. In Supercomputing Frontiers: 4th Asian Conference, SCFA 2018, Singapore, March 26-29, 2018, Proceedings 4 (pp. 159-178). Springer International Publishing.</p>
<p>Cieren, E., Colombet, L., Pitoiset, S., &amp; Namyst, R. (2014). ExaStamp: A parallel framework for molecular dynamics on heterogeneous clusters. In Euro-Par 2014: Parallel Processing Workshops: Euro-Par 2014 International Workshops, Porto, Portugal, August 25-26, 2014, Revised Selected Papers, Part II 20 (pp. 121-132). Springer International Publishing.</p>
<p>Field Physics / Molecular Dynamics:</p>
<p>Soulard, L., Durand, O., Burie, J. R., &amp; Babilotte, K. (2024). Micro-jetting: Areal density calculation from a triangular groove. Journal of Applied Physics, 135(20).</p>
<p>Soulard, L. (2023). Micro-jetting: A semi-analytical model to calculate the velocity and density of the jet from a triangular groove. Journal of Applied Physics, 133(8).</p>
<p>Soulard, L., Carrard, T., &amp; Durand, O. (2022). Molecular dynamics study of the impact of a solid drop on a solid target. Journal of Applied Physics, 131(13).</p>
<p>Soulard, L., Durand, O., Prat, R., &amp; Carrard, T. (2021). High velocity impact of a spherical particle on a surface: Theory and simulation of the jet formation. Journal of Applied Physics, 129(20).</p>
<p>Soulard, L., &amp; Durand, O. (2020). Observation of phase transitions in shocked tin by molecular dynamics. Journal of Applied Physics, 127(16).</p>
<p>Durand, O., Soulard, L., Colombet, L., &amp; Prat, R. (2020). Influence of the phase transitions of shock-loaded tin on microjetting and ejecta production using molecular dynamics simulations. Journal of Applied Physics, 127(17).</p>
<p>Durand, O., Jaouen, S., Soulard, L., Heuze, O., &amp; Colombet, L. (2017). Comparative simulations of microjetting using atomistic and continuous approaches in the presence of viscosity and surface tension. Journal of Applied Physics, 122(13).</p>
</section>
<section id="example-for-rst-usage-math-code-etc">
<h1><span class="section-number">11. </span>Example for rst usage (math, code etc)<a class="headerlink" href="#example-for-rst-usage-math-code-etc" title="Permalink to this heading"></a></h1>
<section id="example-of-math-citatiion">
<h2><span class="section-number">11.1. </span>Example of math citatiion :<a class="headerlink" href="#example-of-math-citatiion" title="Permalink to this heading"></a></h2>
<p>To cite paper, place the appropriate reference in the file source/Bibliography.rst. Then, you can cite it by using this kind of command:</p>
<p>My paper is written by <a class="reference internal" href="bibliography.html#authoryear"><span class="std std-ref">(AaBbCcDd et al.)</span></a></p>
</section>
<section id="example-of-math-with-latex-as-equation">
<h2><span class="section-number">11.2. </span>Example of math with latex as equation :<a class="headerlink" href="#example-of-math-with-latex-as-equation" title="Permalink to this heading"></a></h2>
<div class="math notranslate nohighlight" id="equation-eqtest">
<span class="eqno">(1)<a class="headerlink" href="#equation-eqtest" title="Permalink to this equation"></a></span>\[\frac{ \sum_{t=0}^{N}f(t,k) }{N}\]</div>
</section>
<section id="example-of-math-with-latex-as-inline-text">
<h2><span class="section-number">11.3. </span>Example of math with latex as inline text :<a class="headerlink" href="#example-of-math-with-latex-as-inline-text" title="Permalink to this heading"></a></h2>
<p>Quand \(a &gt; 0\) alors il y a deux solutions à \(ax^2 + bx + c = 0\) et elles sont exactement $$x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}.$$</p>
<p>Le double dollar indique une équation “standalone” sur sa ligne</p>
</section>
<section id="example-of-bash-code">
<h2><span class="section-number">11.4. </span>Example of bash code :<a class="headerlink" href="#example-of-bash-code" title="Permalink to this heading"></a></h2>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>mkdir<span class="w"> </span>my_new_plugin
add_subdirectory<span class="o">(</span>my_new_plugin<span class="o">)</span>
<span class="nb">cd</span><span class="w"> </span>my_new_plugin
vi<span class="w"> </span>CMakeLists.txt
</pre></div>
</div>
</section>
<section id="example-of-cpp-code">
<h2><span class="section-number">11.5. </span>Example of cpp code :<a class="headerlink" href="#example-of-cpp-code" title="Permalink to this heading"></a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">exaSPH</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">TestFunctor</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">exanb</span><span class="o">::</span><span class="n">Vec3d</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="p">};</span>
<span class="w">    </span><span class="n">ONIKA_HOST_DEVICE_FUNC</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">mass</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fx</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fy</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&amp;</span><span class="w"> </span><span class="n">fz</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">fx</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mass</span><span class="p">;</span>
<span class="w">      </span><span class="n">fy</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mass</span><span class="p">;</span>
<span class="w">      </span><span class="n">fz</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mass</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="example-of-yaml-code">
<h2><span class="section-number">11.6. </span>Example of yaml code :<a class="headerlink" href="#example-of-yaml-code" title="Permalink to this heading"></a></h2>
<div class="highlight-yaml notranslate"><div class="highlight"><pre><span></span><span class="nt">domain</span><span class="p">:</span>
<span class="w">  </span><span class="nt">cell_size</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">2 m</span>
<span class="w">  </span><span class="nt">periodic</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">false</span><span class="p p-Indicator">,</span><span class="nv">true</span><span class="p p-Indicator">,</span><span class="nv">false</span><span class="p p-Indicator">]</span>
</pre></div>
</div>
</section>
<section id="example-of-simple-figure">
<h2><span class="section-number">11.7. </span>Example of simple figure :<a class="headerlink" href="#example-of-simple-figure" title="Permalink to this heading"></a></h2>
<figure class="align-center" id="id10">
<a class="reference internal image-reference" href="../_images/rotating_drum_start1.png"><img alt="map to buried treasure" src="../_images/rotating_drum_start1.png" style="width: 300pt;" /></a>
<figcaption>
<p><span class="caption-text">Figure 1: This is the caption of the figure (a simple paragraph).</span><a class="headerlink" href="#id10" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../index.html" class="btn btn-neutral float-left" title="ExaDEM &amp; ExaNBody Documentation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../project_exaDEM/Introduction.html" class="btn btn-neutral float-right" title="1. ExaDEM Software" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Thierry Carrard, Raphaël Prat, Jean-Philippe Perlat, Paul Lafourcade.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>